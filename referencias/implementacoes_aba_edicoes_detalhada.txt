# üìò Manual de Implementa√ß√£o: Ferramentas da Aba "Edi√ß√µes/Edi√ß√£o"

Para implementar corretamente as funcionalidades da aba "Edi√ß√µes/Edi√ß√£o" no seu projeto PySide6 com tema Dracula, vou detalhar as orienta√ß√µes adaptadas especificamente para o reposit√≥rio `melhorapp`. Vamos analisar a estrutura do projeto primeiro para melhor contextualiza√ß√£o.

## üîç An√°lise da Estrutura do Projeto

Vamos come√ßar explorando os arquivos principais relacionados √† aba de Edi√ß√µes:

```list type="issue"
data:
- url: "https://github.com/contatogonetwork/melhorapp/issues/1"
state: "open"
draft: false
title: "Precisamos examinar a estrutura do projeto para entender melhor"
number: 1
created_at: "2025-05-19T13:44:29Z"
closed_at: ""
merged_at: ""
labels: []
author: "copilot"
comments: 0
assignees_avatar_urls: []
```

Vou verificar a estrutura do reposit√≥rio para entender como as implementa√ß√µes devem ser feitas:

```get-github-data
/repos/contatogonetwork/melhorapp/contents
```

Agora que entendo melhor a estrutura, vamos examinar os arquivos relacionados √† interface de usu√°rio:

```get-github-data
/repos/contatogonetwork/melhorapp/contents/ui
```

Vamos verificar os arquivos de implementa√ß√£o:

```get-github-data
/repos/contatogonetwork/melhorapp/contents/views
```

Vamos ver o c√≥digo existente relacionado √†s edi√ß√µes:

```get-github-data
/search/code?q=repo:contatogonetwork/melhorapp+filename:edicoes+path:views
```

Precisamos verificar os modelos de dados dispon√≠veis:

```get-github-data
/repos/contatogonetwork/melhorapp/contents/models
```

Vamos procurar reposit√≥rios de dados:

```get-github-data
/search/code?q=repo:contatogonetwork/melhorapp+filename:repository
```

Agora, com base nessas informa√ß√µes, vou adaptar o manual de orienta√ß√µes especificamente para o seu projeto:

# üìò Manual de Implementa√ß√£o Detalhado: Aba "Edi√ß√µes/Edi√ß√£o"

## ‚úÖ 1. Player de V√≠deo Interativo

### üéØ Objetivo:
Substituir o sistema de exibi√ß√£o de v√≠deo atual por um player completo e interativo.

### üîß Implementa√ß√£o no MelhorApp:

1. **Localiza√ß√£o dos arquivos:**
   - Modifique o arquivo `views/edicoes_view.py` para incluir o novo player
   - Atualize o layout UI correspondente em `ui/edicoes.ui` se necess√°rio

2. **C√≥digo de implementa√ß√£o:**

```python name=views/player_component.py
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QSlider, QLabel
from PySide6.QtMultimedia import QMediaPlayer, QAudioOutput
from PySide6.QtMultimediaWidgets import QVideoWidget
from PySide6.QtGui import QIcon
from utils.resource_path import resource_path
from utils.style_sheets import get_style_sheet

class VideoPlayerComponent(QWidget):
    """Componente de player de v√≠deo com controles"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setupUi()
        self.setupConnections()
        self.setStyleSheet(get_style_sheet("dracula"))
        
    def setupUi(self):
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)
        
        # Widget de v√≠deo
        self.videoWidget = QVideoWidget()
        self.layout.addWidget(self.videoWidget)
        
        # Player e audio
        self.mediaPlayer = QMediaPlayer()
        self.audioOutput = QAudioOutput()
        self.mediaPlayer.setAudioOutput(self.audioOutput)
        self.mediaPlayer.setVideoOutput(self.videoWidget)
        
        # Controles
        self.controlLayout = QHBoxLayout()
        
        # Bot√£o Play/Pause
        self.playButton = QPushButton()
        self.playButton.setIcon(QIcon(resource_path("assets/icons/play.svg")))
        self.playButton.setFixedSize(32, 32)
        self.playButton.setObjectName("playButton")
        
        # Slider de tempo
        self.timeSlider = QSlider(Qt.Horizontal)
        self.timeSlider.setRange(0, 0)
        self.timeSlider.setObjectName("timeSlider")
        
        # Label de tempo
        self.timeLabel = QLabel("00:00 / 00:00")
        self.timeLabel.setObjectName("timeLabel")
        
        # Adiciona controles ao layout
        self.controlLayout.addWidget(self.playButton)
        self.controlLayout.addWidget(self.timeSlider)
        self.controlLayout.addWidget(self.timeLabel)
        
        self.layout.addLayout(self.controlLayout)
        
    def setupConnections(self):
        self.playButton.clicked.connect(self.togglePlayPause)
        self.mediaPlayer.positionChanged.connect(self.positionChanged)
        self.mediaPlayer.durationChanged.connect(self.durationChanged)
        self.timeSlider.sliderMoved.connect(self.setPosition)
        
    @Slot()
    def togglePlayPause(self):
        if self.mediaPlayer.playbackState() == QMediaPlayer.PlaybackState.PlayingState:
            self.mediaPlayer.pause()
            self.playButton.setIcon(QIcon(resource_path("assets/icons/play.svg")))
        else:
            self.mediaPlayer.play()
            self.playButton.setIcon(QIcon(resource_path("assets/icons/pause.svg")))
            
    @Slot(int)
    def positionChanged(self, position):
        self.timeSlider.setValue(position)
        current = self.formatTime(position)
        total = self.formatTime(self.mediaPlayer.duration())
        self.timeLabel.setText(f"{current} / {total}")
        self.currentPosition = position
        
    @Slot(int)
    def durationChanged(self, duration):
        self.timeSlider.setRange(0, duration)
        total = self.formatTime(duration)
        current = self.formatTime(0)
        self.timeLabel.setText(f"{current} / {total}")
        
    @Slot(int)
    def setPosition(self, position):
        self.mediaPlayer.setPosition(position)
        
    def setSource(self, url):
        """Define a fonte do v√≠deo para reprodu√ß√£o"""
        self.mediaPlayer.setSource(url)
        
    def getCurrentTime(self):
        """Retorna a posi√ß√£o atual em milissegundos"""
        return self.mediaPlayer.position()
        
    def formatTime(self, ms):
        """Formata milissegundos para MM:SS"""
        s = ms // 1000
        m = s // 60
        s = s % 60
        return f"{m:02d}:{s:02d}"
```

3. **Integra√ß√£o na View:**

```python name=views/edicoes_view.py
# Importe no topo do arquivo
from views.player_component import VideoPlayerComponent

# Na classe EdicoesView, substitua o QLabel existente:
self.videoPlayer = VideoPlayerComponent()
self.ui.videoLayout.addWidget(self.videoPlayer)  # Assumindo que existe um layout para o v√≠deo

# M√©todo para carregar v√≠deo
def loadVideo(self, video_url):
    self.videoPlayer.setSource(video_url)
    self.videoPlayer.togglePlayPause()  # Auto-play
```

## ‚úÖ 2. Coment√°rios Temporais

### üéØ Objetivo:
Associar coment√°rios ao timestamp do v√≠deo.

### üîß Implementa√ß√£o no MelhorApp:

1. **Atualiza√ß√£o no modelo de coment√°rios:**

```python name=models/comment_model.py
class Comment:
    def __init__(self, id=None, text="", author="", timestamp=None, video_timestamp=0, is_resolved=False):
        self.id = id
        self.text = text
        self.author = author
        self.timestamp = timestamp  # Quando foi postado
        self.video_timestamp = video_timestamp  # Posi√ß√£o do v√≠deo em ms
        self.is_resolved = is_resolved
        
    def to_dict(self):
        return {
            "id": self.id,
            "text": self.text,
            "author": self.author,
            "timestamp": self.timestamp,
            "video_timestamp": self.video_timestamp,
            "is_resolved": self.is_resolved
        }
        
    @classmethod
    def from_dict(cls, data):
        return cls(
            id=data.get("id"),
            text=data.get("text", ""),
            author=data.get("author", ""),
            timestamp=data.get("timestamp"),
            video_timestamp=data.get("video_timestamp", 0),
            is_resolved=data.get("is_resolved", False)
        )
```

2. **Atualiza√ß√£o no componente de coment√°rio:**

```python name=views/comment_item.py
from PySide6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton
from PySide6.QtCore import Qt, Signal
from utils.style_sheets import get_style_sheet
from datetime import datetime

class CommentItem(QWidget):
    goToTimestampRequested = Signal(int)
    resolveRequested = Signal(str)  # ID do coment√°rio
    
    def __init__(self, comment, is_editor=False, parent=None):
        super().__init__(parent)
        self.comment = comment
        self.is_editor = is_editor
        self.setupUi()
        
    def setupUi(self):
        self.layout = QVBoxLayout(self)
        
        # Info do coment√°rio (autor, timestamp)
        self.infoLayout = QHBoxLayout()
        
        self.authorLabel = QLabel(self.comment.author)
        self.authorLabel.setObjectName("authorLabel")
        
        # Formata o timestamp do v√≠deo como MM:SS
        video_seconds = self.comment.video_timestamp // 1000
        video_mins = video_seconds // 60
        video_secs = video_seconds % 60
        timestamp_str = f"{video_mins:02d}:{video_secs:02d}"
        
        self.timestampLabel = QLabel(f"em {timestamp_str}")
        self.timestampLabel.setObjectName("timestampLabel")
        
        self.infoLayout.addWidget(self.authorLabel)
        self.infoLayout.addWidget(self.timestampLabel)
        self.infoLayout.addStretch()
        
        # Bot√µes de a√ß√£o
        self.goToButton = QPushButton("Ir para momento")
        self.goToButton.setObjectName("goToButton")
        self.goToButton.clicked.connect(self.onGoToTimestamp)
        
        self.infoLayout.addWidget(self.goToButton)
        
        # Conte√∫do do coment√°rio
        self.contentLabel = QLabel(self.comment.text)
        self.contentLabel.setWordWrap(True)
        self.contentLabel.setObjectName("contentLabel")
        
        # Layout para marcar como resolvido (apenas para editores)
        self.resolveLayout = QHBoxLayout()
        if self.is_editor and not self.comment.is_resolved:
            self.resolveButton = QPushButton("Marcar como resolvido")
            self.resolveButton.setObjectName("resolveButton")
            self.resolveButton.clicked.connect(self.onResolveRequested)
            self.resolveLayout.addStretch()
            self.resolveLayout.addWidget(self.resolveButton)
        elif self.comment.is_resolved:
            self.resolvedLabel = QLabel("‚úì Resolvido")
            self.resolvedLabel.setObjectName("resolvedLabel")
            self.layout.addWidget(self.resolvedLabel)
            
        # Adiciona tudo ao layout principal
        self.layout.addLayout(self.infoLayout)
        self.layout.addWidget(self.contentLabel)
        self.layout.addLayout(self.resolveLayout)
        
        # Estilo
        if self.comment.is_resolved:
            self.setObjectName("resolvedComment")
        else:
            self.setObjectName("normalComment")
        self.setStyleSheet(get_style_sheet("dracula"))
        
    def onGoToTimestamp(self):
        self.goToTimestampRequested.emit(self.comment.video_timestamp)
        
    def onResolveRequested(self):
        self.resolveRequested.emit(self.comment.id)
```

3. **Integra√ß√£o na View de Edi√ß√µes:**

```python name=views/edicoes_view.py
# Na fun√ß√£o de adicionar coment√°rio
def addComment(self):
    comment_text = self.ui.commentTextEdit.toPlainText()
    if not comment_text.strip():
        return
        
    # Obter a posi√ß√£o atual do v√≠deo
    video_timestamp = self.videoPlayer.getCurrentTime()
    
    # Criar o objeto de coment√°rio
    comment = Comment(
        id=str(uuid.uuid4()),  # Gerador de ID √∫nico
        text=comment_text,
        author=self.current_user.name,
        timestamp=datetime.now(),
        video_timestamp=video_timestamp,
        is_resolved=False
    )
    
    # Salvar no reposit√≥rio
    self.commentRepository.add_comment(comment, self.current_editing.id)
    
    # Adicionar √† interface
    self.displayComment(comment)
    
    # Limpar campo de texto
    self.ui.commentTextEdit.clear()

# Na fun√ß√£o de exibir coment√°rios, ordene por timestamp do v√≠deo
def loadComments(self):
    comments = self.commentRepository.get_comments_by_editing(self.current_editing.id)
    # Ordena pelos timestamps do v√≠deo
    comments.sort(key=lambda c: c.video_timestamp)
    
    # Limpa o layout atual
    self.clearCommentsLayout()
    
    # Adiciona coment√°rios ordenados
    for comment in comments:
        self.displayComment(comment)

# Conecte os sinais dos coment√°rios
def displayComment(self, comment):
    comment_item = CommentItem(
        comment=comment,
        is_editor=self.current_user.role == "editor",
        parent=self.ui.commentsScrollAreaContents
    )
    
    # Conectar sinais
    comment_item.goToTimestampRequested.connect(self.goToVideoTimestamp)
    comment_item.resolveRequested.connect(self.resolveComment)
    
    # Adicionar ao layout
    self.ui.commentsLayout.addWidget(comment_item)
    
# Implementar fun√ß√£o para ir ao timestamp
def goToVideoTimestamp(self, timestamp):
    self.videoPlayer.setPosition(timestamp)
```

## ‚úÖ 3. Marca√ß√£o de Coment√°rio Resolvido

### üéØ Objetivo:
Permitir que editores marquem coment√°rios como resolvidos.

### üîß Implementa√ß√£o no MelhorApp:

```python name=repositories/comment_repository.py
class CommentRepository:
    def __init__(self, database):
        self.db = database
        
    def add_comment(self, comment, editing_id):
        # Implementa√ß√£o para adicionar coment√°rio ao banco
        
    def get_comments_by_editing(self, editing_id):
        # Implementa√ß√£o para buscar coment√°rios
        
    def resolve_comment(self, comment_id):
        """Marca um coment√°rio como resolvido"""
        # Exemplo de implementa√ß√£o
        query = """
            UPDATE comments 
            SET is_resolved = 1 
            WHERE id = ?
        """
        self.db.execute(query, (comment_id,))
        self.db.commit()
        return True
```

Na view:

```python name=views/edicoes_view.py
def resolveComment(self, comment_id):
    """Marca um coment√°rio como resolvido"""
    success = self.commentRepository.resolve_comment(comment_id)
    
    if success:
        # Recarregar coment√°rios para refletir a mudan√ßa
        self.loadComments()
```

## ‚úÖ 4. Lista de Entregas Din√¢mica

### üéØ Objetivo:
Carregar dinamicamente as entregas do banco de dados.

### üîß Implementa√ß√£o no MelhorApp:

1. **Cria√ß√£o do reposit√≥rio de entregas:**

```python name=repositories/editing_repository.py
class EditingRepository:
    def __init__(self, database):
        self.db = database
        
    def get_editings_by_event(self, event_id, editor_id=None):
        """Busca entregas de edi√ß√£o por evento com filtro opcional por editor"""
        query = """
            SELECT e.id, e.title, e.status, e.video_url, e.thumbnail_url,
                   e.created_at, e.due_date, e.approval_status, e.editor_id
            FROM editor_deliveries e
            WHERE e.event_id = ?
        """
        
        params = [event_id]
        
        # Se especificado, filtra por editor
        if editor_id:
            query += " AND e.editor_id = ?"
            params.append(editor_id)
            
        query += " ORDER BY e.due_date ASC"
        
        results = self.db.execute(query, params).fetchall()
        
        editings = []
        for row in results:
            editing = {
                "id": row[0],
                "title": row[1],
                "status": row[2],
                "video_url": row[3],
                "thumbnail_url": row[4],
                "created_at": row[5],
                "due_date": row[6],
                "approval_status": row[7],
                "editor_id": row[8]
            }
            editings.append(editing)
            
        return editings
```

2. **Integra√ß√£o na view:**

```python name=views/edicoes_view.py
def loadEditingsList(self):
    """Carrega a lista de edi√ß√µes para o evento atual"""
    
    self.ui.editingsList.clear()
    
    # Define o editor_id apenas se o usu√°rio for editor
    editor_id = None
    if self.current_user.role == "editor":
        editor_id = self.current_user.id
    
    editings = self.editingRepository.get_editings_by_event(
        event_id=self.current_event.id,
        editor_id=editor_id
    )
    
    for editing in editings:
        item = QListWidgetItem(editing["title"])
        # Armazena o dicion√°rio inteiro como UserRole
        item.setData(Qt.UserRole, editing)
        
        # Define √≠cone com base no status de aprova√ß√£o
        if editing["approval_status"] == "approved":
            item.setIcon(QIcon(resource_path("assets/icons/check.svg")))
        elif editing["approval_status"] == "rejected":
            item.setIcon(QIcon(resource_path("assets/icons/x-circle.svg")))
        elif editing["status"] == "in_progress":
            item.setIcon(QIcon(resource_path("assets/icons/clock.svg")))
        elif editing["status"] == "completed":
            item.setIcon(QIcon(resource_path("assets/icons/check-circle.svg")))
            
        self.ui.editingsList.addItem(item)
```

## ‚úÖ 5. Submiss√£o de Entregas

### üéØ Objetivo:
Permitir que editores enviem entregas de edi√ß√£o.

### üîß Implementa√ß√£o no MelhorApp:

1. **Funcionalidade de submiss√£o:**

```python name=views/edicoes_view.py
from PySide6.QtWidgets import QFileDialog, QInputDialog

def submitEditing(self):
    """Permite submeter uma nova vers√£o da edi√ß√£o"""
    if not self.current_editing or self.current_user.role != "editor":
        return
        
    # Verifica se a edi√ß√£o est√° em progresso
    if self.current_editing.get("status") != "in_progress":
        QMessageBox.warning(
            self,
            "N√£o permitido",
            "Apenas entregas em edi√ß√£o podem ser atualizadas."
        )
        return
        
    # Escolher entre arquivo ou link
    options = ["Upload de arquivo", "Link externo"]
    choice, ok = QInputDialog.getItem(
        self,
        "Tipo de submiss√£o",
        "Como deseja submeter sua entrega?",
        options,
        0,
        False
    )
    
    if not ok:
        return
        
    if choice == options[0]:  # Upload de arquivo
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Selecionar arquivo de v√≠deo",
            "",
            "Arquivos de v√≠deo (*.mp4 *.mov *.avi)"
        )
        
        if not file_path:
            return
            
        # Aqui implementar o upload do arquivo para o servidor
        # Simulando com um placeholder
        video_url = self._uploadVideoFile(file_path)
        
    else:  # Link externo
        link, ok = QInputDialog.getText(
            self,
            "Link da entrega",
            "Cole o link da sua entrega (YouTube, Vimeo, etc):"
        )
        
        if not ok or not link:
            return
            
        video_url = link
        
    # Atualiza o status e link da entrega
    success = self.editingRepository.update_editing_submission(
        self.current_editing["id"],
        video_url,
        "waiting_approval"
    )
    
    if success:
        QMessageBox.information(
            self,
            "Sucesso",
            "Sua entrega foi submetida e est√° aguardando aprova√ß√£o."
        )
        
        # Recarrega a lista e os detalhes
        self.loadEditingsList()
        self.loadEditingDetails(self.current_editing["id"])
```

2. **Atualiza√ß√£o no reposit√≥rio:**

```python name=repositories/editing_repository.py
def update_editing_submission(self, editing_id, video_url, status="waiting_approval"):
    """Atualiza uma entrega com novo v√≠deo e status"""
    query = """
        UPDATE editor_deliveries 
        SET video_url = ?, status = ?, approval_status = ?
        WHERE id = ?
    """
    
    try:
        self.db.execute(query, (video_url, status, "waiting", editing_id))
        self.db.commit()
        return True
    except Exception as e:
        print(f"Erro ao atualizar entrega: {e}")
        return False
```

## ‚úÖ 6. Aprova√ß√£o / Rejei√ß√£o de Entregas

### üéØ Objetivo:
Permitir que clientes aprovem ou rejeitem entregas com justificativa.

### üîß Implementa√ß√£o no MelhorApp:

```python name=views/edicoes_view.py
def setupApprovalButtons(self):
    """Configura os bot√µes de aprova√ß√£o/rejei√ß√£o para clientes"""
    if self.current_user.role != "client":
        self.ui.approvalFrame.hide()
        return
        
    self.ui.approveButton.clicked.connect(self.approveEditing)
    self.ui.rejectButton.clicked.connect(self.rejectEditing)
    
    # Mostra os bot√µes apenas para entregas aguardando aprova√ß√£o
    if self.current_editing and self.current_editing.get("approval_status") == "waiting":
        self.ui.approvalFrame.show()
    else:
        self.ui.approvalFrame.hide()

def approveEditing(self):
    """Aprova a entrega atual"""
    if not self.current_editing:
        return
        
    reply = QMessageBox.question(
        self,
        "Confirmar aprova√ß√£o",
        "Tem certeza que deseja aprovar esta entrega?",
        QMessageBox.Yes | QMessageBox.No,
        QMessageBox.No
    )
    
    if reply == QMessageBox.Yes:
        success = self.editingRepository.update_approval_status(
            self.current_editing["id"],
            "approved"
        )
        
        if success:
            QMessageBox.information(
                self,
                "Sucesso",
                "A entrega foi aprovada com sucesso!"
            )
            
            # Recarrega a lista e os detalhes
            self.loadEditingsList()
            self.loadEditingDetails(self.current_editing["id"])

def rejectEditing(self):
    """Rejeita a entrega atual solicitando ajustes"""
    if not self.current_editing:
        return
        
    reason, ok = QInputDialog.getMultiLine(
        self,
        "Motivo da rejei√ß√£o",
        "Por favor, descreva os ajustes necess√°rios:",
        ""
    )
    
    if ok and reason.strip():
        success = self.editingRepository.update_approval_status(
            self.current_editing["id"],
            "rejected",
            feedback=reason
        )
        
        if success:
            QMessageBox.information(
                self,
                "Enviado",
                "A solicita√ß√£o de ajustes foi enviada ao editor."
            )
            
            # Recarrega a lista e os detalhes
            self.loadEditingsList()
            self.loadEditingDetails(self.current_editing["id"])
```

No reposit√≥rio:

```python name=repositories/editing_repository.py
def update_approval_status(self, editing_id, status, feedback=None):
    """Atualiza o status de aprova√ß√£o de uma entrega"""
    if status not in ["waiting", "approved", "rejected"]:
        return False
        
    query = """
        UPDATE editor_deliveries 
        SET approval_status = ?
        WHERE id = ?
    """
    
    params = [status, editing_id]
    
    try:
        self.db.execute(query, params)
        
        # Se foi rejeitado, registra o feedback
        if status == "rejected" and feedback:
            feedback_query = """
                INSERT INTO editing_feedback (editing_id, feedback, created_at) 
                VALUES (?, ?, datetime('now'))
            """
            self.db.execute(feedback_query, (editing_id, feedback))
            
        self.db.commit()
        return True
    except Exception as e:
        print(f"Erro ao atualizar status de aprova√ß√£o: {e}")
        return False
```

## ‚úÖ 7. Sincroniza√ß√£o Visual de Coment√°rios

### üéØ Objetivo:
Destacar coment√°rios de acordo com a posi√ß√£o atual do v√≠deo.

### üîß Implementa√ß√£o no MelhorApp:

```python name=views/edicoes_view.py
def setupVideoSync(self):
    """Configura a sincroniza√ß√£o entre v√≠deo e coment√°rios"""
    # Timer para verificar a posi√ß√£o do player a cada segundo
    self.syncTimer = QTimer(self)
    self.syncTimer.setInterval(1000)  # 1 segundo
    self.syncTimer.timeout.connect(self.checkCommentSync)
    
    # Inicia quando o v√≠deo estiver em reprodu√ß√£o
    self.videoPlayer.mediaPlayer.playbackStateChanged.connect(self.handlePlaybackChange)
    
def handlePlaybackChange(self, state):
    """Gerencia o timer baseado no estado de reprodu√ß√£o"""
    if state == QMediaPlayer.PlaybackState.PlayingState:
        self.syncTimer.start()
    else:
        self.syncTimer.stop()
        
def checkCommentSync(self):
    """Verifica e destaca coment√°rios pr√≥ximos ao tempo atual do v√≠deo"""
    if not self.videoPlayer or not hasattr(self, "commentItems"):
        return
        
    current_pos = self.videoPlayer.getCurrentTime()
    window_start = max(0, current_pos - 2000)  # 2 segundos antes
    window_end = current_pos + 2000  # 2 segundos depois
    
    # Percorre os widgets de coment√°rio
    for i in range(self.ui.commentsLayout.count()):
        item = self.ui.commentsLayout.itemAt(i).widget()
        if isinstance(item, CommentItem):
            is_active = window_start <= item.comment.video_timestamp <= window_end
            
            if is_active:
                # Destaca o coment√°rio
                item.setProperty("active", True)
                item.setStyleSheet(get_style_sheet("dracula_active_comment"))
                
                # Scroll para o coment√°rio
                self.ui.commentsScrollArea.ensureWidgetVisible(item)
            else:
                # Remove o destaque
                item.setProperty("active", False)
                item.setStyleSheet("")
```

## ‚úÖ 8. Lista de Coment√°rios Ordenada por Timestamp

### üéØ Objetivo:
Manter os coment√°rios ordenados por timestamp do v√≠deo.

### üîß Implementa√ß√£o no MelhorApp:

```python name=views/edicoes_view.py
def loadComments(self):
    """Carrega e exibe coment√°rios ordenados por timestamp do v√≠deo"""
    if not self.current_editing:
        return
        
    comments = self.commentRepository.get_comments_by_editing(self.current_editing["id"])
    
    # Ordena por timestamp do v√≠deo
    comments.sort(key=lambda c: c.video_timestamp)
    
    # Limpa o layout atual
    self.clearCommentsLayout()
    
    # Armazena refer√™ncias aos itens de coment√°rios
    self.commentItems = []
    
    # Adiciona coment√°rios ordenados
    for comment in comments:
        item = CommentItem(
            comment=comment,
            is_editor=self.current_user.role == "editor"
        )
        
        # Conecta sinais
        item.goToTimestampRequested.connect(self.goToVideoTimestamp)
        item.resolveRequested.connect(self.resolveComment)
        
        # Adiciona ao layout
        self.ui.commentsLayout.addWidget(item)
        self.commentItems.append(item)
```

## ‚úÖ 9. Tela Responsiva

### üéØ Objetivo:
Garantir que a interface seja responsiva em diferentes resolu√ß√µes.

### üîß Implementa√ß√£o no MelhorApp:

```python name=views/edicoes_view.py
def setupResponsiveLayout(self):
    """Configura o layout responsivo da aba de edi√ß√µes"""
    # Configurar QSplitter
    self.ui.mainSplitter.setStretchFactor(0, 2)  # √Årea do v√≠deo
    self.ui.mainSplitter.setStretchFactor(1, 1)  # Lista de coment√°rios
    
    # Tamanhos m√≠nimos
    self.ui.videoFrame.setMinimumWidth(480)
    self.ui.videoFrame.setMinimumHeight(270)
    
    self.ui.commentsFrame.setMinimumWidth(250)
    
    # Configura√ß√£o para tela reduzida
    screen_rect = QApplication.primaryScreen().availableGeometry()
    if screen_rect.width() < 1024:
        # Modo compacto
        self.ui.mainSplitter.setOrientation(Qt.Vertical)
    else:
        # Modo normal
        self.ui.mainSplitter.setOrientation(Qt.Horizontal)
```

## ‚úÖ 10. Dados Din√¢micos

### üéØ Objetivo:
Preencher o painel lateral de v√≠deos com dados reais do banco.

### üîß Implementa√ß√£o no MelhorApp:

```python name=views/edicoes_view.py
def initView(self):
    """Inicializa a view com dados din√¢micos"""
    # Configura os reposit√≥rios
    self.editingRepository = EditingRepository(self.db)
    self.commentRepository = CommentRepository(self.db)
    
    # Carrega a lista de edi√ß√µes
    self.loadEditingsList()
    
    # Conecta sinais
    self.ui.editingsList.itemClicked.connect(self.onEditingItemClicked)
    self.ui.commentButton.clicked.connect(self.addComment)
    
    # Configura bot√µes de submiss√£o/aprova√ß√£o
    if self.current_user.role == "editor":
        self.ui.submitButton.show()
        self.ui.submitButton.clicked.connect(self.submitEditing)
    else:
        self.ui.submitButton.hide()
        
    self.setupApprovalButtons()
    self.setupVideoSync()
    self.setupResponsiveLayout()
    
def onEditingItemClicked(self, item):
    """Manipula o clique em um item da lista de edi√ß√µes"""
    editing_data = item.data(Qt.UserRole)
    if editing_data:
        self.loadEditingDetails(editing_data["id"])
        
def loadEditingDetails(self, editing_id):
    """Carrega os detalhes de uma edi√ß√£o espec√≠fica"""
    # Busca os detalhes completos da edi√ß√£o
    editing = self.editingRepository.get_editing_by_id(editing_id)
    
    if not editing:
        return
        
    self.current_editing = editing
    
    # Atualiza a interface com os detalhes
    self.ui.titleLabel.setText(editing["title"])
    self.ui.statusLabel.setText(self.formatStatus(editing["status"]))
    
    # Carrega o v√≠deo
    if editing["video_url"]:
        self.videoPlayer.setSource(QUrl(editing["video_url"]))
        self.videoPlayer.mediaPlayer.play()
    
    # Carrega os coment√°rios
    self.loadComments()
    
    # Atualiza visibilidade dos bot√µes de acordo com o status
    self.updateActionButtons()
```

---

## üìù Considera√ß√µes Finais

1. **Estrutura de Dados**:
   - Certifique-se de que seu banco de dados cont√©m as tabelas necess√°rias: `editor_deliveries`, `comments` e `editing_feedback`.

2. **Tema Dracula**:
   - Todo o c√≥digo fornecido j√° est√° preparado para receber o tema Dracula atrav√©s da fun√ß√£o `get_style_sheet`.

3. **Integra√ß√£o Gradual**:
   - Recomenda-se implementar as funcionalidades na ordem apresentada, pois existem depend√™ncias entre elas.

4. **Testes**:
   - Ap√≥s implementar cada se√ß√£o, fa√ßa testes para garantir seu funcionamento adequado antes de prosseguir.

5. **Permiss√µes por Papel**:
   - O c√≥digo j√° diferencia as permiss√µes entre "editor" e "client", garantindo que apenas as a√ß√µes permitidas sejam exibidas para cada tipo de usu√°rio.

Siga este manual para implementar todas as funcionalidades necess√°rias na aba "Edi√ß√µes" do projeto MelhorApp de maneira organizada e coerente com a estrutura atual do projeto.