# Plano de Implementação das Abas BRIEFING e TIMELINE para melhorapp

Analisei o projeto `melhorapp` e o detalhamento fornecido. Vou apresentar um plano de implementação organizado e realista, adaptado à estrutura atual do projeto.

## Visão Geral da Implementação

As implementações das abas BRIEFING e TIMELINE devem seguir o mesmo padrão arquitetural já existente no projeto, mantendo coerência com:

1. **Padrão de arquitetura MVC**:
   - Widgets (GUI) em `gui/widgets/`
   - Repositórios (lógica de acesso a dados) em `database/`
   - Modelos em `database/models/`

2. **Estilo visual Dracula** já implementado
3. **Sistema de eventos e sinais** para comunicação entre componentes

## 1. Plano de Implementação da Aba BRIEFING

### 1.1 Estrutura de Banco de Dados

```python name=database/schema/create_briefing_tables.py
import sqlite3
import os
from pathlib import Path


def create_briefing_tables(db_path="database/gonetwork.db"):
    """Cria as tabelas necessárias para o sistema de briefing"""
    
    conn = None
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Tabela principal de briefings
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS briefings (
            id TEXT PRIMARY KEY,
            event_id INTEGER NOT NULL UNIQUE,
            info_geral TEXT,
            estilo_referencias TEXT, 
            entregas_realtime TEXT,
            entregas_pos_evento TEXT,
            created_at TEXT NOT NULL,
            updated_at TEXT NOT NULL,
            FOREIGN KEY (event_id) REFERENCES events(id) ON DELETE CASCADE
        )
        ''')
        
        # Tabela para patrocinadores no briefing
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS briefing_patrocinadores (
            id TEXT PRIMARY KEY,
            briefing_id TEXT NOT NULL,
            nome TEXT NOT NULL,
            horario TEXT,
            horario_livre INTEGER DEFAULT 0,
            responsavel_id INTEGER,
            realtime INTEGER DEFAULT 0,
            realtime_horario TEXT,
            editor_id INTEGER,
            orientacoes TEXT,
            created_at TEXT NOT NULL,
            updated_at TEXT NOT NULL,
            FOREIGN KEY (briefing_id) REFERENCES briefings(id) ON DELETE CASCADE,
            FOREIGN KEY (responsavel_id) REFERENCES users(id),
            FOREIGN KEY (editor_id) REFERENCES users(id)
        )
        ''')
        
        # Tabela para programação de palcos
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS briefing_palcos (
            id TEXT PRIMARY KEY,
            briefing_id TEXT NOT NULL,
            palco TEXT NOT NULL,
            artista TEXT NOT NULL,
            horario_inicio TEXT NOT NULL,
            horario_fim TEXT,
            observacoes TEXT,
            created_at TEXT NOT NULL,
            updated_at TEXT NOT NULL,
            FOREIGN KEY (briefing_id) REFERENCES briefings(id) ON DELETE CASCADE
        )
        ''')
        
        conn.commit()
        print("✅ Tabelas para briefing criadas com sucesso")
        return True
        
    except sqlite3.Error as e:
        print(f"❌ Erro ao criar tabelas de briefing: {e}")
        if conn:
            conn.rollback()
        return False
        
    finally:
        if conn:
            conn.close()


if __name__ == "__main__":
    # Caminho do banco de dados
    db_path = Path(__file__).parent.parent / "gonetwork.db"
    create_briefing_tables(db_path)
```

















1.2 Repositório de Briefing 


import json
import sqlite3
import uuid
from datetime import datetime

from database.Database import Database
from utils.logger import get_logger

logger = get_logger()


class BriefingRepository:
    """Repositório para operações relacionadas a briefings de eventos"""

    def __init__(self):
        self.db = Database()
        
    def create_or_update_briefing(self, event_id, dados_dict):
        """Cria ou atualiza um briefing para um evento específico
        
        Args:
            event_id (int): ID do evento
            dados_dict (dict): Dicionário com dados do briefing
                
        Returns:
            str: ID do briefing criado/atualizado ou None se falhar
        """
        try:
            current_time = datetime.now().isoformat()
            
            # Verificar se já existe um briefing para este evento
            query = "SELECT id FROM briefings WHERE event_id = ?"
            existing = self.db.fetch_one(query, (event_id,))
            
            if existing:
                briefing_id = existing[0]
                # Limpar os itens existentes
                self.db.execute(
                    "DELETE FROM briefing_items WHERE briefing_id = ?", 
                    (briefing_id,)
                )
                
                # Atualizar o timestamp
                self.db.execute(
                    "UPDATE briefings SET updated_at = ? WHERE id = ?",
                    (current_time, briefing_id)
                )
            else:
                # Criar novo briefing
                briefing_id = str(uuid.uuid4())
                self.db.execute(
                    "INSERT INTO briefings (id, event_id, created_at, updated_at) VALUES (?, ?, ?, ?)",
                    (briefing_id, event_id, current_time, current_time)
                )
                
            # Inserir itens do briefing
            for tipo, conteudo in dados_dict.items():
                item_id = str(uuid.uuid4())
                
                # Converter conteúdo para JSON se não for string
                if not isinstance(conteudo, str):
                    conteudo = json.dumps(conteudo, ensure_ascii=False)
                    
                self.db.execute(
                    """
                    INSERT INTO briefing_items (id, briefing_id, type, content, created_at, updated_at) 
                    VALUES (?, ?, ?, ?, ?, ?)
                    """,
                    (item_id, briefing_id, tipo, conteudo, current_time, current_time)
                )
                
            logger.info(f"Briefing {'atualizado' if existing else 'criado'} para evento {event_id}")
            return briefing_id
                
        except Exception as e:
            logger.error(f"Erro ao criar/atualizar briefing: {e}")
            return None
    
    def get_briefing_by_event(self, event_id):
        """Obtém o briefing completo de um evento
        
        Args:
            event_id (int): ID do evento
            
        Returns:
            dict: Dados completos do briefing ou None se não existir
        """
        try:
            # Buscar o ID do briefing
            query = "SELECT id FROM briefings WHERE event_id = ?"
            result = self.db.fetch_one(query, (event_id,))
            
            if not result:
                logger.info(f"Nenhum briefing encontrado para o evento {event_id}")
                return None
                
            briefing_id = result[0]
            
            # Buscar todos os itens do briefing
            items = self.get_briefing_items_by_briefing(briefing_id)
            
            if not items:
                return {"id": briefing_id, "event_id": event_id}
                
            # Construir o dicionário com os itens
            briefing = {"id": briefing_id, "event_id": event_id}
            
            for tipo, conteudo in items.items():
                try:
                    # Tentar converter JSON para dicionário/lista
                    briefing[tipo] = json.loads(conteudo)
                except (json.JSONDecodeError, TypeError):
                    # Se não for JSON válido, manter como string
                    briefing[tipo] = conteudo
                    
            return briefing
            
        except Exception as e:
            logger.error(f"Erro ao obter briefing para evento {event_id}: {e}")
            return None
    
    def get_briefing_items_by_briefing(self, briefing_id):
        """Obtém todos os itens de um briefing
        
        Args:
            briefing_id (str): ID do briefing
            
        Returns:
            dict: Dicionário com tipos e conteúdos dos itens
        """
        try:
            query = "SELECT type, content FROM briefing_items WHERE briefing_id = ?"
            rows = self.db.fetch_all(query, (briefing_id,))
            
            if not rows:
                return {}
                
            # Construir dicionário tipo -> conteúdo
            items = {}
            for row in rows:
                items[row[0]] = row[1]
                
            return items
            
        except Exception as e:
            logger.error(f"Erro ao obter itens do briefing {briefing_id}: {e}")
            return {}
    
    def get_briefing_items_by_type(self, briefing_id, tipo_item):
        """Obtém itens de um tipo específico de um briefing
        
        Args:
            briefing_id (str): ID do briefing
            tipo_item (str): Tipo do item
            
        Returns:
            str: Conteúdo do item ou None se não existir
        """
        try:
            query = "SELECT content FROM briefing_items WHERE briefing_id = ? AND type = ?"
            result = self.db.fetch_one(query, (briefing_id, tipo_item))
            
            if not result:
                return None
                
            content = result[0]
            
            # Tentar converter para objeto Python se for JSON
            try:
                return json.loads(content)
            except (json.JSONDecodeError, TypeError):
                return content
                
        except Exception as e:
            logger.error(f"Erro ao obter item '{tipo_item}' do briefing {briefing_id}: {e}")
            return None





















1.3 Script de Criação de Tabelas do Briefing



-- Script SQL para criar as tabelas de briefing no banco de dados SQLite

-- Tabela principal de briefings
CREATE TABLE IF NOT EXISTS briefings (
  id TEXT PRIMARY KEY,
  event_id INTEGER NOT NULL UNIQUE,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  FOREIGN KEY (event_id) REFERENCES events(id) ON DELETE CASCADE
);

-- Tabela para itens de briefing (estrutura flexível)
CREATE TABLE IF NOT EXISTS briefing_items (
  id TEXT PRIMARY KEY,
  briefing_id TEXT NOT NULL,
  type TEXT NOT NULL,  -- Tipo do item: info_geral, estilo_referencias, patrocinadores, programacao, entregas_realtime, etc
  content TEXT NOT NULL,  -- Conteúdo serializado como JSON ou texto
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  FOREIGN KEY (briefing_id) REFERENCES briefings(id) ON DELETE CASCADE
);

-- Índice para busca rápida por briefing_id e tipo
CREATE INDEX IF NOT EXISTS idx_briefing_items ON briefing_items (briefing_id, type);













import sqlite3
import os
from pathlib import Path


def create_briefing_tables(db_path="database/gonetwork.db"):
    """Cria as tabelas necessárias para o sistema de briefing"""
    
    conn = None
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Tabela principal de briefings
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS briefings (
          id TEXT PRIMARY KEY,
          event_id INTEGER NOT NULL UNIQUE,
          created_at TEXT NOT NULL,
          updated_at TEXT NOT NULL,
          FOREIGN KEY (event_id) REFERENCES events(id) ON DELETE CASCADE
        )
        ''')
        
        # Tabela para itens de briefing (estrutura flexível)
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS briefing_items (
          id TEXT PRIMARY KEY,
          briefing_id TEXT NOT NULL,
          type TEXT NOT NULL,
          content TEXT NOT NULL,
          created_at TEXT NOT NULL,
          updated_at TEXT NOT NULL,
          FOREIGN KEY (briefing_id) REFERENCES briefings(id) ON DELETE CASCADE
        )
        ''')
        
        # Índice para busca rápida
        cursor.execute('''
        CREATE INDEX IF NOT EXISTS idx_briefing_items ON briefing_items (briefing_id, type)
        ''')
        
        conn.commit()
        print("✅ Tabelas para briefing criadas com sucesso")
        return True
        
    except sqlite3.Error as e:
        print(f"❌ Erro ao criar tabelas de briefing: {e}")
        if conn:
            conn.rollback()
        return False
        
    finally:
        if conn:
            conn.close()


if __name__ == "__main__":
    # Caminho do banco de dados
    db_path = Path(__file__).parent.parent / "gonetwork.db"
    create_briefing_tables(db_path)



















1.4 Widget de Briefing




import json
import uuid
from datetime import datetime

from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QIcon
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QComboBox, QTextEdit, 
    QPushButton, QTableWidget, QTableWidgetItem, QScrollArea, QFrame, 
    QGroupBox, QLineEdit, QTimeEdit, QCheckBox, QDateEdit, QListWidget, 
    QListWidgetItem, QMessageBox, QSplitter, QTabWidget, QFormLayout,
    QSpinBox
)

import gui.themes.dracula as style
from database.BriefingRepository import BriefingRepository
from database.EventRepository import EventRepository
from database.TeamRepository import TeamRepository
from database.TimelineRepository import TimelineRepository
from utils.logger import get_logger


class BriefingWidget(QWidget):
    """Widget para visualização e edição de briefings de eventos"""
    
    timeline_gerada = Signal(int)  # Sinal emitido quando a timeline é gerada (recebe event_id)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # Instanciar repositórios
        self.briefing_repo = BriefingRepository()
        self.event_repo = EventRepository()
        self.team_repo = TeamRepository()
        self.timeline_repo = TimelineRepository()
        
        self.logger = get_logger()
        
        # Estado atual
        self.current_event_id = None
        self.current_briefing = None
        self.patrocinadores_widgets = []
        
        # Inicializar UI
        self.init_ui()
        
    def init_ui(self):
        """Inicializa a interface de usuário"""
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        
        # Cabeçalho
        header_layout = QHBoxLayout()
        
        title_label = QLabel("Briefing")
        title_label.setStyleSheet(f"font-size: 18pt; color: {style.foreground_color};")
        
        # Seletor de evento
        event_layout = QHBoxLayout()
        event_label = QLabel("Evento:")
        
        self.event_selector = QComboBox()
        self.event_selector.setMinimumWidth(250)
        self.event_selector.setStyleSheet(style.combobox_style)
        self.event_selector.currentIndexChanged.connect(self.on_event_changed)
        
        event_layout.addWidget(event_label)
        event_layout.addWidget(self.event_selector)
        event_layout.addStretch()
        
        header_layout.addWidget(title_label)
        header_layout.addStretch()
        header_layout.addLayout(event_layout)
        
        main_layout.addLayout(header_layout)
        
        # Conteúdo principal - TabbedWidget
        self.tab_widget = QTabWidget()
        self.tab_widget.setStyleSheet(style.tab_style)
        
        # Tab 1: Informações Gerais
        info_tab = QWidget()
        info_layout = QVBoxLayout(info_tab)
        
        # Informações gerais
        info_geral_label = QLabel("Informações Gerais:")
        info_geral_label.setStyleSheet(f"font-weight: bold; color: {style.foreground_color};")
        self.info_geral_edit = QTextEdit()
        self.info_geral_edit.setStyleSheet(style.input_style)
        self.info_geral_edit.setPlaceholderText("Informações gerais sobre o evento, objetivo, público-alvo, etc.")
        
        # Estilo e referências
        estilo_label = QLabel("Estilo e Referências:")
        estilo_label.setStyleSheet(f"font-weight: bold; color: {style.foreground_color};")
        self.estilo_edit = QTextEdit()
        self.estilo_edit.setStyleSheet(style.input_style)
        self.estilo_edit.setPlaceholderText("Estilo visual, referências de edição, links de inspiração, etc.")
        
        info_layout.addWidget(info_geral_label)
        info_layout.addWidget(self.info_geral_edit)
        info_layout.addSpacing(15)
        info_layout.addWidget(estilo_label)
        info_layout.addWidget(self.estilo_edit)
        
        # Tab 2: Patrocinadores
        patrocinadores_tab = QWidget()
        patrocinadores_layout = QVBoxLayout(patrocinadores_tab)
        
        # Header
        patrocinadores_header = QHBoxLayout()
        patrocinadores_title = QLabel("Ações de Patrocinadores")
        patrocinadores_title.setStyleSheet(f"font-weight: bold; font-size: 14pt; color: {style.foreground_color};")
        
        self.add_patrocinador_btn = QPushButton("Adicionar Patrocinador")
        self.add_patrocinador_btn.setStyleSheet(style.btn_primary)
        self.add_patrocinador_btn.setIcon(QIcon("./resources/icons/add.svg"))
        self.add_patrocinador_btn.clicked.connect(self.add_patrocinador)
        
        patrocinadores_header.addWidget(patrocinadores_title)
        patrocinadores_header.addStretch()
        patrocinadores_header.addWidget(self.add_patrocinador_btn)
        
        # Área de rolagem para patrocinadores
        self.patrocinadores_scroll = QScrollArea()
        self.patrocinadores_scroll.setWidgetResizable(True)
        self.patrocinadores_scroll.setFrameShape(QFrame.NoFrame)
        
        self.patrocinadores_container = QWidget()
        self.patrocinadores_layout = QVBoxLayout(self.patrocinadores_container)
        self.patrocinadores_layout.setAlignment(Qt.AlignTop)
        self.patrocinadores_layout.addStretch()
        
        self.patrocinadores_scroll.setWidget(self.patrocinadores_container)
        
        patrocinadores_layout.addLayout(patrocinadores_header)
        patrocinadores_layout.addWidget(self.patrocinadores_scroll)
        
        # Tab 3: Programação de Palcos
        palcos_tab = QWidget()
        palcos_layout = QVBoxLayout(palcos_tab)
        
        # Header
        palcos_header = QHBoxLayout()
        palcos_title = QLabel("Programação de Palcos")
        palcos_title.setStyleSheet(f"font-weight: bold; font-size: 14pt; color: {style.foreground_color};")
        
        self.add_palco_btn = QPushButton("Adicionar Show/Apresentação")
        self.add_palco_btn.setStyleSheet(style.btn_primary)
        self.add_palco_btn.setIcon(QIcon("./resources/icons/add.svg"))
        self.add_palco_btn.clicked.connect(self.add_palco_item)
        
        palcos_header.addWidget(palcos_title)
        palcos_header.addStretch()
        palcos_header.addWidget(self.add_palco_btn)
        
        # Tabela de programação de palcos
        self.palcos_table = QTableWidget()
        self.palcos_table.setColumnCount(5)
        self.palcos_table.setHorizontalHeaderLabels(["Palco", "Artista/Atração", "Início", "Fim", "Observações"])
        self.palcos_table.horizontalHeader().setStretchLastSection(True)
        self.palcos_table.setStyleSheet(style.table_style)
        
        palcos_layout.addLayout(palcos_header)
        palcos_layout.addWidget(self.palcos_table)
        
        # Tab 4: Entregas
        entregas_tab = QWidget()
        entregas_layout = QVBoxLayout(entregas_tab)
        
        # Splitter horizontal para dividir entregas realtime e pós-evento
        entregas_splitter = QSplitter(Qt.Horizontal)
        
        # Entregas Real Time
        realtime_widget = QWidget()
        realtime_layout = QVBoxLayout(realtime_widget)
        
        realtime_header = QHBoxLayout()
        realtime_title = QLabel("Entregas Real Time")
        realtime_title.setStyleSheet(f"font-weight: bold; font-size: 14pt; color: {style.foreground_color};")
        
        self.add_realtime_btn = QPushButton("Adicionar Entrega")
        self.add_realtime_btn.setStyleSheet(style.btn_primary)
        self.add_realtime_btn.setIcon(QIcon("./resources/icons/add.svg"))
        self.add_realtime_btn.clicked.connect(self.add_entrega_realtime)
        
        realtime_header.addWidget(realtime_title)
        realtime_header.addStretch()
        realtime_header.addWidget(self.add_realtime_btn)
        
        # Tabela de entregas real time
        self.realtime_table = QTableWidget()
        self.realtime_table.setColumnCount(5)
        self.realtime_table.setHorizontalHeaderLabels(
            ["Título", "Hora", "Editor", "Plataforma", "Orientações"]
        )
        self.realtime_table.horizontalHeader().setStretchLastSection(True)
        self.realtime_table.setStyleSheet(style.table_style)
        
        realtime_layout.addLayout(realtime_header)
        realtime_layout.addWidget(self.realtime_table)
        
        # Entregas Pós-Evento
        pos_evento_widget = QWidget()
        pos_evento_layout = QVBoxLayout(pos_evento_widget)
        
        pos_evento_title = QLabel("Entregas Pós-Evento")
        pos_evento_title.setStyleSheet(f"font-weight: bold; font-size: 14pt; color: {style.foreground_color};")
        
        deadline_layout = QHBoxLayout()
        deadline_label = QLabel("Deadline Geral:")
        self.deadline_date = QDateEdit()
        self.deadline_date.setCalendarPopup(True)
        self.deadline_date.setStyleSheet(style.input_style)
        
        deadline_layout.addWidget(deadline_label)
        deadline_layout.addWidget(self.deadline_date)
        deadline_layout.addStretch()
        
        # Pacotes de entrega
        pacotes_label = QLabel("Pacotes de Entrega:")
        pacotes_label.setStyleSheet(f"font-weight: bold; color: {style.foreground_color};")
        
        self.pacotes_list = QListWidget()
        self.pacotes_list.setStyleSheet(style.table_style)
        self.pacotes_list.setMaximumHeight(200)
        
        # Adicionar pacotes padrão
        pacotes_padrao = [
            "Aftermovie Principal (3-5 min)",
            "Highlights (1 min)",
            "Teaser (30 seg)",
            "Stories (15 seg)",
            "Melhores Momentos por Dia",
            "Conteúdo para Patrocinadores"
        ]
        
        for pacote in pacotes_padrao:
            item = QListWidgetItem(pacote)
            item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
            item.setCheckState(Qt.Unchecked)
            self.pacotes_list.addItem(item)
        
        # Botão para adicionar pacote personalizado
        self.add_pacote_btn = QPushButton("Adicionar Pacote Personalizado")
        self.add_pacote_btn.setStyleSheet(style.btn_secondary)
        self.add_pacote_btn.clicked.connect(self.add_pacote_personalizado)
        
        # Observações finais
        obs_finais_label = QLabel("Observações Finais:")
        obs_finais_label.setStyleSheet(f"font-weight: bold; color: {style.foreground_color};")
        self.obs_finais_edit = QTextEdit()
        self.obs_finais_edit.setStyleSheet(style.input_style)
        self.obs_finais_edit.setPlacherText("Observações gerais sobre as entregas pós-evento")
        
        pos_evento_layout.addWidget(pos_evento_title)
        pos_evento_layout.addLayout(deadline_layout)
        pos_evento_layout.addWidget(pacotes_label)
        pos_evento_layout.addWidget(self.pacotes_list)
        pos_evento_layout.addWidget(self.add_pacote_btn)
        pos_evento_layout.addWidget(obs_finais_label)
        pos_evento_layout.addWidget(self.obs_finais_edit)
        
        # Adicionar widgets ao splitter
        entregas_splitter.addWidget(realtime_widget)
        entregas_splitter.addWidget(pos_evento_widget)
        entregas_splitter.setSizes([int(self.width() * 0.5), int(self.width() * 0.5)])
        
        entregas_layout.addWidget(entregas_splitter)
        
        # Adicionar tabs
        self.tab_widget.addTab(info_tab, "Informações Gerais")
        self.tab_widget.addTab(patrocinadores_tab, "Patrocinadores")
        self.tab_widget.addTab(palcos_tab, "Programação")
        self.tab_widget.addTab(entregas_tab, "Entregas")
        
        main_layout.addWidget(self.tab_widget)
        
        # Botões de ação no rodapé
        actions_layout = QHBoxLayout()
        
        self.salvar_btn = QPushButton("Salvar Briefing")
        self.salvar_btn.setStyleSheet(style.btn_primary)
        self.salvar_btn.setIcon(QIcon("./resources/icons/save.svg"))
        self.salvar_btn.clicked.connect(self.salvar_briefing)
        
        self.gerar_timeline_btn = QPushButton("Gerar Timeline")
        self.gerar_timeline_btn.setStyleSheet(style.btn_secondary)
        self.gerar_timeline_btn.setIcon(QIcon("./resources/icons/timeline.svg"))
        self.gerar_timeline_btn.clicked.connect(self.gerar_timeline)
        
        actions_layout.addStretch()
        actions_layout.addWidget(self.salvar_btn)
        actions_layout.addWidget(self.gerar_timeline_btn)
        
        main_layout.addLayout(actions_layout)
        
        # Carregar dados iniciais
        self.load_events()
        
    def load_events(self):
        """Carrega os eventos disponíveis no seletor"""
        try:
            events = self.event_repo.get_all()
            self.event_selector.clear()
            
            if events:
                for event in events:
                    self.event_selector.addItem(event["name"], event["id"])
                    
        except Exception as e:
            self.logger.error(f"Erro ao carregar eventos: {e}")
            QMessageBox.critical(self, "Erro", f"Erro ao carregar eventos: {str(e)}")
    
    def on_event_changed(self, index):
        """Manipula a mudança do evento selecionado"""
        if index < 0:
            return
            
        event_id = self.event_selector.currentData()
        self.current_event_id = event_id
        
        # Carregar briefing do evento
        self.load_briefing(event_id)
    
    def load_briefing(self, event_id):
        """Carrega o briefing para o evento selecionado"""
        try:
            briefing = self.briefing_repo.get_briefing_by_event(event_id)
            self.current_briefing = briefing
            
            # Limpar interface
            self.clear_interface()
            
            if not briefing:
                return
                
            # Informações gerais
            self.info_geral_edit.setText(briefing.get("info_geral", ""))
            self.estilo_edit.setText(briefing.get("estilo_referencias", ""))
            
            # Patrocinadores
            for patrocinador in briefing.get("patrocinadores", []):
                self.add_patrocinador(patrocinador)
                
            # Programação de palcos
            self.load_programacao_palcos(briefing.get("programacao_palcos", []))
            
            # Entregas
            self.load_entregas_realtime(briefing.get("entregas_realtime", []))
            self.load_entregas_pos_evento(briefing.get("entregas_pos_evento", {}))
            
        except Exception as e:
            self.logger.error(f"Erro ao carregar briefing: {e}")
            QMessageBox.critical(self, "Erro", f"Erro ao carregar briefing: {str(e)}")
    
    def clear_interface(self):
        """Limpa todos os campos da interface"""
        # Limpar textos
        self.info_geral_edit.clear()
        self.estilo_edit.clear()
        
        # Limpar patrocinadores
        for widget in self.patrocinadores_widgets:
            widget.deleteLater()
        self.patrocinadores_widgets = []
        
        # Limpar programação
        while self.palcos_table.rowCount() > 0:
            self.palcos_table.removeRow(0)
            
        # Limpar entregas realtime
        while self.realtime_table.rowCount() > 0:
            self.realtime_table.removeRow(0)
            
        # Limpar pacotes
        for i in range(self.pacotes_list.count()):
            self.pacotes_list.item(i).setCheckState(Qt.Unchecked)
            
        # Limpar observações
        self.obs_finais_edit.clear()
        
        # Resetar deadline
        self.deadline_date.setDate(datetime.now().date())
    
    def add_patrocinador(self, data=None):
        """Adiciona um widget de patrocinador"""
        patrocinador_box = QGroupBox("Ação de Patrocinador")
        patrocinador_box.setStyleSheet(f"""
            QGroupBox {{
                border: 1px solid {style.comment_color};
                border-radius: 5px;
                margin-top: 15px;
                padding-top: 10px;
                background-color: {style.BG_THREE};
            }}
            QGroupBox::title {{
                color: {style.foreground_color};
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px;
            }}
        """)
        
        layout = QFormLayout()
        layout.setContentsMargins(10, 15, 10, 10)
        layout.setSpacing(10)
        
        # Campos do patrocinador
        nome_edit = QLineEdit()
        nome_edit.setStyleSheet(style.input_style)
        nome_edit.setPlaceholderText("Nome do patrocinador/ação")
        
        horario_edit = QTimeEdit()
        horario_edit.setStyleSheet(style.input_style)
        
        horario_livre_check = QCheckBox("Horário Livre")
        horario_livre_check.setStyleSheet(style.toggle_style)
        
        # Carregar equipe para seleção
        responsavel_combo = QComboBox()
        responsavel_combo.setStyleSheet(style.combobox_style)
        self.load_team_members(responsavel_combo)
        
        realtime_check = QCheckBox("Entrega Real Time")
        realtime_check.setStyleSheet(style.toggle_style)
        
        realtime_time = QTimeEdit()
        realtime_time.setStyleSheet(style.input_style)
        realtime_time.setEnabled(False)
        
        editor_combo = QComboBox()
        editor_combo.setStyleSheet(style.combobox_style)
        self.load_editors(editor_combo)
        editor_combo.setEnabled(False)
        
        # Conectar checkboxes a ações
        realtime_check.stateChanged.connect(
            lambda state: (realtime_time.setEnabled(state == Qt.Checked),
                          editor_combo.setEnabled(state == Qt.Checked))
        )
        
        horario_livre_check.stateChanged.connect(
            lambda state: horario_edit.setEnabled(state != Qt.Checked)
        )
        
        orientacoes_edit = QTextEdit()
        orientacoes_edit.setStyleSheet(style.input_style)
        orientacoes_edit.setMaximumHeight(80)
        orientacoes_edit.setPlaceholderText("Orientações específicas para esta ação")
        
        # Adicionar campos ao layout
        layout.addRow("Nome da Ação:", nome_edit)
        layout.addRow("Horário:", horario_edit)
        layout.addRow("", horario_livre_check)
        layout.addRow("Responsável:", responsavel_combo)
        layout.addRow("", realtime_check)
        layout.addRow("Horário de Entrega:", realtime_time)
        layout.addRow("Editor Responsável:", editor_combo)
        layout.addRow("Orientações:", orientacoes_edit)
        
        # Botão de remover
        remove_btn = QPushButton("Remover")
        remove_btn.setStyleSheet(style.btn_danger)
        remove_btn.setIcon(QIcon("./resources/icons/delete.svg"))
        remove_btn.clicked.connect(lambda: self.remove_patrocinador(patrocinador_box))
        
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()
        btn_layout.addWidget(remove_btn)
        layout.addRow("", btn_layout)
        
        patrocinador_box.setLayout(layout)
        self.patrocinadores_layout.insertWidget(self.patrocinadores_layout.count() - 1, patrocinador_box)
        self.patrocinadores_widgets.append(patrocinador_box)
        
        # Preencher dados se informados
        if data:
            nome_edit.setText(data.get("nome", ""))
            
            if data.get("horario"):
                horario = datetime.strptime(data.get("horario"), "%H:%M").time()
                horario_edit.setTime(horario)
                
            horario_livre_check.setChecked(bool(data.get("horario_livre")))
            
            if data.get("responsavel_id"):
                index = responsavel_combo.findData(data.get("responsavel_id"))
                if index >= 0:
                    responsavel_combo.setCurrentIndex(index)
                    
            realtime_check.setChecked(bool(data.get("realtime")))
            
            if data.get("realtime_horario"):
                realtime_horario = datetime.strptime(data.get("realtime_horario"), "%H:%M").time()
                realtime_time.setTime(realtime_horario)
                
            if data.get("editor_id"):
                index = editor_combo.findData(data.get("editor_id"))
                if index >= 0:
                    editor_combo.setCurrentIndex(index)
                    
            orientacoes_edit.setText(data.get("orientacoes", ""))
        
        return patrocinador_box
    
    def remove_patrocinador(self, widget):
        """Remove um widget de patrocinador"""
        self.patrocinadores_widgets.remove(widget)
        widget.deleteLater()
    
    def load_team_members(self, combobox):
        """Carrega os membros da equipe no combobox"""
        try:
            if not self.current_event_id:
                return
                
            combobox.clear()
            combobox.addItem("Selecione...", None)
            
            members = self.team_repo.get_event_team(self.current_event_id)
            if members:
                for member in members:
                    combobox.addItem(member["name"], member["id"])
                    
        except Exception as e:
            self.logger.error(f"Erro ao carregar membros da equipe: {e}")
    
    def load_editors(self, combobox):
        """Carrega os editores no combobox"""
        try:
            if not self.current_event_id:
                return
                
            combobox.clear()
            combobox.addItem("Selecione...", None)
            
            members = self.team_repo.get_event_team(self.current_event_id)
            if members:
                for member in members:
                    if "edito" in member["role"].lower():  # editor, editora, etc.
                        combobox.addItem(member["name"], member["id"])
                    
        except Exception as e:
            self.logger.error(f"Erro ao carregar editores: {e}")
    
    def add_palco_item(self):
        """Adiciona uma linha à tabela de programação de palcos"""
        row = self.palcos_table.rowCount()
        self.palcos_table.insertRow(row)
        
        # Criar células editáveis
        for i in range(5):
            item = QTableWidgetItem()
            if i < 4:  # Não formatamos a coluna de observações
                item.setTextAlignment(Qt.AlignCenter)
            self.palcos_table.setItem(row, i, item)
    
    def load_programacao_palcos(self, programacao):
        """Carrega a programação de palcos na tabela"""
        self.palcos_table.setRowCount(0)
        
        for item in programacao:
            row = self.palcos_table.rowCount()
            self.palcos_table.insertRow(row)
            
            palco_item = QTableWidgetItem(item.get("palco", ""))
            artista_item = QTableWidgetItem(item.get("artista", ""))
            inicio_item = QTableWidgetItem(item.get("horario_inicio", ""))
            fim_item = QTableWidgetItem(item.get("horario_fim", ""))
            obs_item = QTableWidgetItem(item.get("observacoes", ""))
            
            palco_item.setTextAlignment(Qt.AlignCenter)
            artista_item.setTextAlignment(Qt.AlignCenter)
            inicio_item.setTextAlignment(Qt.AlignCenter)
            fim_item.setTextAlignment(Qt.AlignCenter)
            
            self.palcos_table.setItem(row, 0, palco_item)
            self.palcos_table.setItem(row, 1, artista_item)
            self.palcos_table.setItem(row, 2, inicio_item)
            self.palcos_table.setItem(row, 3, fim_item)
            self.palcos_table.setItem(row, 4, obs_item)
    
    def add_entrega_realtime(self):
        """Adiciona uma linha à tabela de entregas em real time"""
        row = self.realtime_table.rowCount()
        self.realtime_table.insertRow(row)
        
        # Título
        self.realtime_table.setItem(row, 0, QTableWidgetItem(""))
        
        # Horário
        self.realtime_table.setItem(row, 1, QTableWidgetItem(""))
        
        # Editor (combobox)
        editor_combo = QComboBox()
        editor_combo.setStyleSheet(style.combobox_style)
        self.load_editors(editor_combo)
        self.realtime_table.setCellWidget(row, 2, editor_combo)
        
        # Plataforma
        plataforma_combo = QComboBox()
        plataforma_combo.addItems(["Instagram", "Facebook", "Twitter", "TikTok", "YouTube", "Outra"])
        plataforma_combo.setStyleSheet(style.combobox_style)
        self.realtime_table.setCellWidget(row, 3, plataforma_combo)
        
        # Orientações
        self.realtime_table.setItem(row, 4, QTableWidgetItem(""))
    
    def load_entregas_realtime(self, entregas):
        """Carrega as entregas real time na tabela"""
        self.realtime_table.setRowCount(0)
        
        for entrega in entregas:
            row = self.realtime_table.rowCount()
            self.realtime_table.insertRow(row)
            
            # Título
            self.realtime_table.setItem(row, 0, QTableWidgetItem(entrega.get("titulo", "")))
            
            # Horário
            self.realtime_table.setItem(row, 1, QTableWidgetItem(entrega.get("hora", "")))
            
            # Editor (combobox)
            editor_combo = QComboBox()
            editor_combo.setStyleSheet(style.combobox_style)
            self.load_editors(editor_combo)
            
            if entrega.get("editor_id"):
                index = editor_combo.findData(entrega.get("editor_id"))
                if index >= 0:
                    editor_combo.setCurrentIndex(index)
                    
            self.realtime_table.setCellWidget(row, 2, editor_combo)
            
            # Plataforma
            plataforma_combo = QComboBox()
            plataforma_combo.addItems(["Instagram", "Facebook", "Twitter", "TikTok", "YouTube", "Outra"])
            plataforma_combo.setStyleSheet(style.combobox_style)
            
            if entrega.get("plataforma"):
                index = plataforma_combo.findText(entrega.get("plataforma"))
                if index >= 0:
                    plataforma_combo.setCurrentIndex(index)
                    
            self.realtime_table.setCellWidget(row, 3, plataforma_combo)
            
            # Orientações
            self.realtime_table.setItem(row, 4, QTableWidgetItem(entrega.get("orientacoes", "")))
    
    def load_entregas_pos_evento(self, dados):
        """Carrega as configurações de entregas pós-evento"""
        # Deadline
        if dados.get("deadline"):
            try:
                deadline_date = datetime.strptime(dados.get("deadline"), "%Y-%m-%d").date()
                self.deadline_date.setDate(deadline_date)
            except:
                self.deadline_date.setDate(datetime.now().date())
                
        # Pacotes
        pacotes = dados.get("pacotes", [])
        
        for i in range(self.pacotes_list.count()):
            item = self.pacotes_list.item(i)
            if item.text() in pacotes:
                item.setCheckState(Qt.Checked)
            else:
                item.setCheckState(Qt.Unchecked)
                
        # Adicionar pacotes personalizados
        for pacote in pacotes:
            # Verificar se o pacote já existe na lista
            found = False
            for i in range(self.pacotes_list.count()):
                if self.pacotes_list.item(i).text() == pacote:
                    found = True
                    break
                    
            if not found:
                item = QListWidgetItem(pacote)
                item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
                item.setCheckState(Qt.Checked)
                self.pacotes_list.addItem(item)
        
        # Observações
        self.obs_finais_edit.setText(dados.get("observacoes", ""))
    
    def add_pacote_personalizado(self):
        """Adiciona um pacote personalizado à lista"""
        from PySide6.QtWidgets import QInputDialog
        
        texto, ok = QInputDialog.getText(
            self, "Adicionar Pacote", "Descrição do pacote:"
        )
        
        if ok and texto:
            item = QListWidgetItem(texto)
            item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
            item.setCheckState(Qt.Checked)
            self.pacotes_list.addItem(item)
    
    def salvar_briefing(self):
        """Salva o briefing atual"""
        if not self.current_event_id:
            QMessageBox.warning(self, "Aviso", "Selecione um evento primeiro.")
            return
            
        try:
            # Coletar dados do briefing
            dados = self.coletar_dados_briefing()
            
            # Salvar no repositório
            briefing_id = self.briefing_repo.create_or_update_briefing(
                self.current_event_id, dados
            )
            
            if briefing_id:
                QMessageBox.information(
                    self, "Sucesso", "Briefing salvo com sucesso!"
                )
                self.load_briefing(self.current_event_id)
            else:
                QMessageBox.critical(
                    self, "Erro", "Não foi possível salvar o briefing."
                )
                
        except Exception as e:
            self.logger.error(f"Erro ao salvar briefing: {e}")
            QMessageBox.critical(self, "Erro", f"Erro ao salvar briefing: {str(e)}")
    
    def coletar_dados_briefing(self):
        """Coleta todos os dados do briefing da interface"""
        dados = {
            "info_geral": self.info_geral_edit.toPlainText(),
            "estilo_referencias": self.estilo_edit.toPlainText(),
            "patrocinadores": self.coletar_patrocinadores(),
            "programacao_palcos": self.coletar_programacao_palcos(),
            "entregas_realtime": self.coletar_entregas_realtime(),
            "entregas_pos_evento": self.coletar_entregas_pos_evento()
        }
        
        return dados
    
    def coletar_patrocinadores(self):
        """Coleta os dados de patrocinadores da interface"""
        patrocinadores = []
        
        for widget in self.patrocinadores_widgets:
            # Pegar os widgets dentro do grupo
            nome_edit = widget.findChild(QLineEdit)
            horario_edit = widget.findChild(QTimeEdit)
            horario_livre = widget.findChild(QCheckBox, "Horário Livre")
            responsavel_combo = widget.findChild(QComboBox)
            realtime_check = widget.findChild(QCheckBox, "Entrega Real Time")
            realtime_time = widget.findChild(QTimeEdit)
            editor_combo = widget.findChild(QComboBox)
            orientacoes_edit = widget.findChild(QTextEdit)
            
            # Coletar dados
            patrocinador = {
                "nome": nome_edit.text(),
                "horario": horario_edit.time().toString("HH:mm") if not horario_livre.isChecked() else "",
                "horario_livre": horario_livre.isChecked(),
                "responsavel_id": responsavel_combo.currentData(),
                "realtime": realtime_check.isChecked(),
                "realtime_horario": realtime_time.time().toString("HH:mm") if realtime_check.isChecked() else "",
                "editor_id": editor_combo.currentData() if realtime_check.isChecked() else None,
                "orientacoes": orientacoes_edit.toPlainText()
            }
            
            patrocinadores.append(patrocinador)
            
        return patrocinadores
    
    def coletar_programacao_palcos(self):
        """Coleta os dados da programação de palcos da tabela"""
        programacao = []
        
        for row in range(self.palcos_table.rowCount()):
            # Verificar se a linha está preenchida
            if not self.palcos_table.item(row, 0) or not self.palcos_table.item(row, 0).text().strip():
                continue
                
            item = {
                "palco": self.palcos_table.item(row, 0).text(),
                "artista": self.palcos_table.item(row, 1).text() if self.palcos_table.item(row, 1) else "",
                "horario_inicio": self.palcos_table.item(row, 2).text() if self.palcos_table.item(row, 2) else "",
                "horario_fim": self.palcos_table.item(row, 3).text() if self.palcos_table.item(row, 3) else "",
                "observacoes": self.palcos_table.item(row, 4).text() if self.palcos_table.item(row, 4) else ""
            }
            
            programacao.append(item)
            
        return programacao
    
    def coletar_entregas_realtime(self):
        """Coleta os dados de entregas realtime da tabela"""
        entregas = []
        
        for row in range(self.realtime_table.rowCount()):
            # Verificar se a linha está preenchida
            if not self.realtime_table.item(row, 0) or not self.realtime_table.item(row, 0).text().strip():
                continue
                
            editor_combo = self.realtime_table.cellWidget(row, 2)
            plataforma_combo = self.realtime_table.cellWidget(row, 3)
            
            entrega = {
                "titulo": self.realtime_table.item(row, 0).text(),
                "hora": self.realtime_table.item(row, 1).text() if self.realtime_table.item(row, 1) else "",
                "editor_id": editor_combo.currentData() if editor_combo else None,
                "plataforma": plataforma_combo.currentText() if plataforma_combo else "",
                "orientacoes": self.realtime_table.item(row, 4).text() if self.realtime_table.item(row, 4) else ""
            }
            
            entregas.append(entrega)
            
        return entregas
    
    def coletar_entregas_pos_evento(self):
        """Coleta os dados de entregas pós evento"""
        # Coletar pacotes selecionados
        pacotes = []
        for i in range(self.pacotes_list.count()):
            item = self.pacotes_list.item(i)
            if item.checkState() == Qt.Checked:
                pacotes.append(item.text())
                
        dados = {
            "deadline": self.deadline_date.date().toString("yyyy-MM-dd"),
            "pacotes": pacotes,
            "observacoes": self.obs_finais_edit.toPlainText()
        }
        
        return dados
    
    def gerar_timeline(self):
        """Gera a timeline com base no briefing atual"""
        if not self.current_event_id:
            QMessageBox.warning(self, "Aviso", "Selecione um evento primeiro.")
            return
            
        try:
            # Primeiro salvar o briefing atual
            self.salvar_briefing()
            
            # Gerar timeline
            success = self.timeline_repo.generate_timeline_from_briefing(self.current_event_id)
            
            if success:
                QMessageBox.information(
                    self, "Sucesso", "Timeline gerada com sucesso! Acesse a aba Timeline para visualizar."
                )
                # Emitir sinal de que a timeline foi gerada
                self.timeline_gerada.emit(self.current_event_id)
            else:
                QMessageBox.critical(
                    self, "Erro", "Não foi possível gerar a timeline."
                )
                
        except Exception as e:
            self.logger.error(f"Erro ao gerar timeline: {e}")
            QMessageBox.critical(self, "Erro", f"Erro ao gerar timeline: {str(e)}")
























## 2. Implementação da Aba TIMELINE

### 2.1 Estrutura de Banco de Dados

```python name=database/schema/create_timeline_tables.py
import sqlite3
import os
from pathlib import Path


def create_timeline_tables(db_path="database/gonetwork.db"):
    """Cria as tabelas necessárias para o sistema de timeline"""
    
    conn = None
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Tabela de eventos da timeline
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS timeline_events (
            id TEXT PRIMARY KEY,
            event_id INTEGER NOT NULL,
            briefing_item_id TEXT,
            title TEXT NOT NULL,
            start_time TEXT NOT NULL,
            end_time TEXT,
            type TEXT CHECK(type IN ('captacao','edicao','entrega','preparacao','outro')),
            status TEXT DEFAULT 'Pendente' CHECK(status IN ('Pendente','Em Andamento','Concluido','Atrasado','Cancelado')),
            responsible_id INTEGER,
            notes TEXT,
            created_at TEXT NOT NULL,
            updated_at TEXT NOT NULL,
            FOREIGN KEY (event_id) REFERENCES events(id) ON DELETE CASCADE,
            FOREIGN KEY (responsible_id) REFERENCES users(id)
        )
        ''')
        
        # Criar índice para melhorar performance
        cursor.execute('''
        CREATE INDEX IF NOT EXISTS idx_timeline 
        ON timeline_events (event_id, start_time, type, responsible_id)
        ''')
        
        conn.commit()
        print("✅ Tabelas para timeline criadas com sucesso")
        return True
        
    except sqlite3.Error as e:
        print(f"❌ Erro ao criar tabelas de timeline: {e}")
        if conn:
            conn.rollback()
        return False
        
    finally:
        if conn:
            conn.close()


if __name__ == "__main__":
    # Caminho do banco de dados
    db_path = Path(__file__).parent.parent / "gonetwork.db"
    create_timeline_tables(db_path)
```

### 2.2 Repositório de Timeline

```python name=database/TimelineRepository.py
import json
import sqlite3
import uuid
from datetime import datetime, timedelta

from database.Database import Database
from database.BriefingRepository import BriefingRepository
from database.TeamRepository import TeamRepository
from utils.logger import get_logger

logger = get_logger()


class TimelineRepository:
    """Repositório para operações relacionadas à timeline de eventos"""

    def __init__(self):
        self.db = Database()
        self.briefing_repo = BriefingRepository()
        self.team_repo = TeamRepository()
        
    def generate_timeline_from_briefing(self, event_id):
        """Gera uma timeline com base no briefing do evento
        
        Args:
            event_id (int): ID do evento
            
        Returns:
            bool: True se a timeline foi gerada com sucesso
        """
        try:
            # Buscar o briefing do evento
            briefing = self.briefing_repo.get_briefing_by_event(event_id)
            if not briefing:
                logger.warning(f"Briefing não encontrado para o evento {event_id}")
                return False
            
            # Limpar timeline existente
            self._clear_event_timeline(event_id)
            
            # Timestamp atual para created_at e updated_at
            current_time = datetime.now().isoformat()
            
            # Gerar timeline a partir de patrocinadores
            patrocinadores = briefing.get("patrocinadores", [])
            for p in patrocinadores:
                # Evento de captação
                if p.get("horario") or p.get("horario_livre"):
                    title = f"Captação: {p.get('nome', 'Patrocinador')}"
                    
                    # Se horário livre, definir um placeholder no início do evento
                    start_time = p.get("horario", "08:00")
                    
                    # Calcular hora de fim (estimativa de 30 minutos)
                    start_dt = datetime.strptime(start_time, "%H:%M")
                    end_dt = start_dt + timedelta(minutes=30)
                    end_time = end_dt.strftime("%H:%M")
                    
                    self._add_timeline_event({
                        "event_id": event_id,
                        "title": title,
                        "start_time": start_time,
                        "end_time": end_time,
                        "type": "captacao",
                        "status": "Pendente" if p.get("horario_livre") else "Pendente",
                        "responsible_id": p.get("responsavel_id"),
                        "notes": f"Captação para {p.get('nome')}. " + p.get("orientacoes", ""),
                        "created_at": current_time,
                        "updated_at": current_time
                    })
                
                # Se há entrega em realtime
                if p.get("realtime") and p.get("realtime_horario"):
                    title = f"Entrega: {p.get('nome', 'Patrocinador')}"
                    
                    # Horário de entrega
                    start_time = p.get("realtime_horario")
                    
                    # Calcular hora de fim da edição (começa 1h antes)
                    start_dt = datetime.strptime(start_time, "%H:%M")
                    
                    # Adicionar evento de edição
                    edit_start_dt = start_dt - timedelta(hours=1)
                    edit_start_time = edit_start_dt.strftime("%H:%M")
                    
                    self._add_timeline_event({
                        "event_id": event_id,
                        "title": f"Edição: {p.get('nome', 'Patrocinador')}",
                        "start_time": edit_start_time,
                        "end_time": start_time,
                        "type": "edicao",
                        "status": "Pendente",
                        "responsible_id": p.get("editor_id"),
                        "notes": f"Edição para entrega de {p.get('nome')}. " + p.get("orientacoes", ""),
                        "created_at": current_time,
                        "updated_at": current_time
                    })
                    
                    # Adicionar evento de entrega
                    self._add_timeline_event({
                        "event_id": event_id,
                        "title": title,
                        "start_time": start_time,
                        "end_time": None,  # Entregas não têm horário de fim definido
                        "type": "entrega",
                        "status": "Pendente",
                        "responsible_id": p.get("editor_id"),
                        "notes": f"Entrega para {p.get('nome')}. " + p.get("orientacoes", ""),
                        "created_at": current_time,
                        "updated_at": current_time
                    })
            
            # Gerar timeline a partir da programação de palcos
            palcos = briefing.get("programacao_palcos", [])
            for p in palcos:
                title = f"Captação: {p.get('artista', 'Show')} - {p.get('palco', 'Palco')}"
                
                # Horários de início e fim
                start_time = p.get("horario_inicio", "")
                end_time = p.get("horario_fim", "")
                
                if start_time:
                    self._add_timeline_event({
                        "event_id": event_id,
                        "title": title,
                        "start_time": start_time,
                        "end_time": end_time,
                        "type": "captacao",
                        "status": "Pendente",
                        "responsible_id": None,  # Não definido no briefing
                        "notes": p.get("observacoes", ""),
                        "created_at": current_time,
                        "updated_at": current_time
                    })
            
            # Gerar timeline a partir das entregas realtime
            entregas_realtime = briefing.get("entregas_realtime", [])
            for e in entregas_realtime:
                title = f"Entrega: {e.get('titulo', 'Conteúdo')} - {e.get('plataforma', '')}"
                
                # Horário de entrega
                start_time = e.get("hora", "")
                
                if start_time:
                    # Calcular hora de fim da edição (começa 1h antes)
                    start_dt = datetime.strptime(start_time, "%H:%M")
                    
                    # Adicionar evento de edição
                    edit_start_dt = start_dt - timedelta(hours=1)
                    edit_start_time = edit_start_dt.strftime("%H:%M")
                    
                    self._add_timeline_event({
                        "event_id": event_id,
                        "title": f"Edição: {e.get('titulo', 'Conteúdo')}",
                        "start_time": edit_start_time,
                        "end_time": start_time,
                        "type": "edicao",
                        "status": "Pendente",
                        "responsible_id": e.get("editor_id"),
                        "notes": f"Edição para {e.get('plataforma', '')}. " + e.get("orientacoes", ""),
                        "created_at": current_time,
                        "updated_at": current_time
                    })
                    
                    # Adicionar evento de entrega
                    self._add_timeline_event({
                        "event_id": event_id,
                        "title": title,
                        "start_time": start_time,
                        "end_time": None,
                        "type": "entrega",
                        "status": "Pendente",
                        "responsible_id": e.get("editor_id"),
                        "notes": e.get("orientacoes", ""),
                        "created_at": current_time,
                        "updated_at": current_time
                    })
            
            # Timeline para entregas pós evento
            entregas_pos = briefing.get("entregas_pos_evento", {})
            deadline = entregas_pos.get("deadline", "")
            pacotes = entregas_pos.get("pacotes", [])
            
            if deadline and pacotes:
                # Adicionar evento de preparação para as entregas pós-evento
                self._add_timeline_event({
                    "event_id": event_id,
                    "title": "Preparação Entregas Pós-Evento",
                    "start_time": "00:00",  # Início do dia do evento
                    "end_time": None,
                    "type": "preparacao",
                    "status": "Pendente",
                    "responsible_id": None,
                    "notes": f"Preparação para entregas pós-evento: {', '.join(pacotes)}",
                    "created_at": current_time,
                    "updated_at": current_time
                })
            
            logger.info(f"Timeline gerada com sucesso para o evento {event_id}")
            return True
            
        except Exception as e:
            logger.error(f"Erro ao gerar timeline: {e}")
            return False
    
    def _clear_event_timeline(self, event_id):
        """Limpa a timeline de um evento"""
        try:
            self.db.execute("DELETE FROM timeline_events WHERE event_id = ?", (event_id,))
            return True
        except Exception as e:
            logger.error(f"Erro ao limpar timeline do evento {event_id}: {e}")
            return False
    
    def _add_timeline_event(self, event_data):
        """Adiciona um evento à timeline"""
        try:
            event_id = str(uuid.uuid4())
            
            query = """
            INSERT INTO timeline_events (
                id, event_id, title, start_time, end_time, type, 
                status, responsible_id, notes, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """
            
            params = (
                event_id,
                event_data["event_id"],
                event_data["title"],
                event_data["start_time"],
                event_data["end_time"],
                event_data["type"],
                event_data["status"],
                event_data["responsible_id"],
                event_data["notes"],
                event_data["created_at"],
                event_data["updated_at"]
            )
            
            self.db.execute(query, params)
            return event_id
            
        except Exception as e:
            logger.error(f"Erro ao adicionar evento à timeline: {e}")
            return None
    
    def get_timeline_by_event(self, event_id):
        """Obtém todos os eventos da timeline para um evento
        
        Args:
            event_id (int): ID do evento
            
        Returns:
            list: Lista de eventos da timeline
        """
        try:
            query = """
            SELECT id, event_id, title, start_time, end_time, type,
                   status, responsible_id, notes, created_at, updated_at
            FROM timeline_events 
            WHERE event_id = ?
            ORDER BY start_time
            """
            
            rows = self.db.fetch_all(query, (event_id,))
            
            if not rows:
                return []
                
            timeline_events = []
            
            for row in rows:
                event = {
                    "id": row[0],
                    "event_id": row[1],
                    "title": row[2],
                    "start_time": row[3],
                    "end_time": row[4],
                    "type": row[5],
                    "status": row[6],
                    "responsible_id": row[7],
                    "notes": row[8],
                    "created_at": row[9],
                    "updated_at": row[10],
                    "responsible_name": None
                }
                
                # Adicionar nome do responsável se houver
                if event["responsible_id"]:
                    user = self.team_repo.get_user_by_id(event["responsible_id"])
                    if user:
                        event["responsible_name"] = user.get("name", "")
                
                timeline_events.append(event)
                
            return timeline_events
            
        except Exception as e:
            logger.error(f"Erro ao buscar timeline do evento {event_id}: {e}")
            return []
            
    def update_timeline_item(self, item_id, dados):
        """Atualiza um item da timeline
        
        Args:
            item_id (str): ID do item da timeline
            dados (dict): Dados a serem atualizados
            
        Returns:
            bool: True se atualizado com sucesso
        """
        try:
            current_time = datetime.now().isoformat()
            
            # Construir a query dinâmica
            query_parts = []
            params = []
            
            if "title" in dados:
                query_parts.append("title = ?")
                params.append(dados["title"])
                
            if "start_time" in dados:
                query_parts.append("start_time = ?")
                params.append(dados["start_time"])
                
            if "end_time" in dados:
                query_parts.append("end_time = ?")
                params.append(dados["end_time"])
                
            if "type" in dados:
                query_parts.append("type = ?")
                params.append(dados["type"])
                
            if "status" in dados:
                query_parts.append("status = ?")
                params.append(dados["status"])
                
            if "responsible_id" in dados:
                query_parts.append("responsible_id = ?")
                params.append(dados["responsible_id"])
                
            if "notes" in dados:
                query_parts.append("notes = ?")
                params.append(dados["notes"])
            
            # Sempre atualizar updated_at
            query_parts.append("updated_at = ?")
            params.append(current_time)
            
            if not query_parts:
                logger.warning("Nenhum dado para atualizar na timeline")
                return False
                
            # Adicionar o id ao final dos parâmetros
            params.append(item_id)
            
            # Construir a query completa
            query = f"UPDATE timeline_events SET {', '.join(query_parts)} WHERE id = ?"
            
            self.db.execute(query, params)
            logger.info(f"Item da timeline atualizado: {item_id}")
            
            return True
            
        except Exception as e:
            logger.error(f"Erro ao atualizar item da timeline: {e}")
            return False
    
    def check_conflicts(self, event_id):
        """Verifica conflitos na timeline
        
        Args:
            event_id (int): ID do evento
            
        Returns:
            list: Lista de conflitos encontrados
        """
        try:
            conflicts = []
            
            # Buscar todos os eventos da timeline
            timeline_events = self.get_timeline_by_event(event_id)
            
            # Verificar conflitos de responsáveis (mesmo responsável em eventos simultâneos)
            responsible_events = {}
            
            for event in timeline_events:
                if event["responsible_id"] and event["start_time"]:
                    if event["responsible_id"] not in responsible_events:
                        responsible_events[event["responsible_id"]] = []
                        
                    responsible_events[event["responsible_id"]].append(event)
            
            # Para cada responsável, verificar eventos sobrepostos
            for resp_id, events in responsible_events.items():
                if len(events) < 2:
                    continue
                    
                # Ordenar por hora de início
                events.sort(key=lambda e: e["start_time"])
                
                for i in range(len(events) - 1):
                    curr_event = events[i]
                    next_event = events[i + 1]
                    
                    # Se o evento atual não tem fim definido, não há como determinar se há conflito
                    if not curr_event["end_time"]:
                        continue
                        
                    # Se o próximo evento começa antes do fim do atual, há conflito
                    if curr_event["end_time"] > next_event["start_time"]:
                        conflicts.append({
                            "type": "responsible_overlap",
                            "responsible_id": resp_id,
                            "responsible_name": curr_event["responsible_name"],
                            "events": [
                                {
                                    "id": curr_event["id"],
                                    "title": curr_event["title"],
                                    "time": f"{curr_event['start_time']} - {curr_event['end_time']}"
                                },
                                {
                                    "id": next_event["id"],
                                    "title": next_event["title"],
                                    "time": f"{next_event['start_time']} - {next_event['end_time'] if next_event['end_time'] else '?'}"
                                }
                            ]
                        })
            
            # Verificar conflitos de entregas com edições (entrega sem edição anterior)
            for event in timeline_events:
                if event["type"] == "entrega" and event["start_time"]:
                    # Verificar se existe um evento de edição que termina quando esta entrega começa
                    has_edit = False
                    
                    for edit_event in timeline_events:
                        if (edit_event["type"] == "edicao" and 
                            edit_event["end_time"] == event["start_time"] and
                            edit_event["title"].replace("Edição:", "").strip() == event["title"].replace("Entrega:", "").strip()):
                            has_edit = True
                            break
                            
                    if not has_edit:
                        conflicts.append({
                            "type": "delivery_without_edit",
                            "event": {
                                "id": event["id"],
                                "title": event["title"],
                                "time": event["start_time"]
                            }
                        })
            
            return conflicts
            
        except Exception as e:
            logger.error(f"Erro ao verificar conflitos na timeline: {e}")
            return []
```

### 2.3 Widget de Timeline


import math
from datetime import datetime, timedelta

from PySide6.QtCore import QPointF, Qt, QRectF, Signal, QSize, QTimer
from PySide6.QtGui import QColor, QPainter, QPen, QBrush, QFont, QPainterPath, QWheelEvent, QMouseEvent
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QComboBox, 
    QScrollArea, QFrame, QSlider, QPushButton, QCheckBox,
    QGraphicsView, QGraphicsScene, QGraphicsRectItem, QGraphicsTextItem,
    QGraphicsLineItem, QMessageBox, QDialog, QFormLayout, QTimeEdit, 
    QTextEdit, QGraphicsItem, QMenu, QAction
)

import gui.themes.dracula as style
from database.EventRepository import EventRepository
from database.TeamRepository import TeamRepository
from database.TimelineRepository import TimelineRepository
from utils.logger import get_logger


class TimelineItemWidget(QGraphicsRectItem):
    """Item gráfico para representar um evento na timeline"""
    
    # Constantes para cores baseadas no tipo
    COLORS = {
        'captacao': QColor(style.green_color),
        'edicao': QColor(style.purple_color),
        'entrega': QColor(style.orange_color),
        'preparacao': QColor(style.cyan_color),
        'outro': QColor(style.comment_color)
    }
    
    # Constantes para estados
    STATUS_COLORS = {
        'Pendente': QColor(style.comment_color).lighter(140),
        'Em Andamento': QColor(style.orange_color),
        'Concluido': QColor(style.green_color),
        'Atrasado': QColor(style.red_color),
        'Cancelado': QColor('#777777')
    }
    
    def __init__(self, timeline_item, time_scale, parent=None):
        """Inicializa o item gráfico
        
        Args:
            timeline_item (dict): Dados do item da timeline
            time_scale (float): Escala de tempo (pixels por minuto)
            parent: Item pai
        """
        super().__init__(parent)
        
        self.item_data = timeline_item
        self.time_scale = time_scale
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setFlag(QGraphicsItem.ItemIsMovable, True)
        
        # Calcular posição e tamanho com base no tempo
        self._setup_geometry()
        
        # Configurar aparência
        self._setup_appearance()
        
        # Adicionar textos
        self._add_texts()
    
    def _setup_geometry(self):
        """Configura a geometria do item com base nos horários"""
        # Converter horários para minutos desde a meia-noite
        start_time_str = self.item_data.get('start_time', '00:00')
        
        try:
            h, m = map(int, start_time_str.split(':'))
            start_minutes = h * 60 + m
        except (ValueError, AttributeError):
            start_minutes = 0
            
        # Calcular posição X com base na escala de tempo
        x_pos = start_minutes * self.time_scale
        
        # Altura fixa para itens
        height = 60
        
        # Calcular largura com base no tempo de fim (se existir)
        end_time_str = self.item_data.get('end_time')
        
        if end_time_str:
            try:
                h, m = map(int, end_time_str.split(':'))
                end_minutes = h * 60 + m
                width = max(100, (end_minutes - start_minutes) * self.time_scale)
            except (ValueError, AttributeError):
                width = 100  # Largura padrão
        else:
            width = 100  # Largura padrão
        
        # Ajustar posição Y com base no tipo
        y_offset = self._get_y_offset()
        
        # Definir geometria
        self.setRect(QRectF(x_pos, y_offset, width, height))
    
    def _get_y_offset(self):
        """Determina a posição Y com base no tipo de evento"""
        type_map = {
            'captacao': 0,
            'preparacao': 70,
            'edicao': 140,
            'entrega': 210,
            'outro': 280
        }
        
        return type_map.get(self.item_data.get('type', 'outro'), 0)
    
    def _setup_appearance(self):
        """Configura a aparência visual do item"""
        # Cor baseada no tipo
        item_type = self.item_data.get('type', 'outro')
        base_color = self.COLORS.get(item_type, QColor(style.comment_color))
        
        # Modificar cor com base no status
        status = self.item_data.get('status', 'Pendente')
        
        # Definir cores
        if status == 'Concluido':
            bg_color = self.STATUS_COLORS.get(status, QColor(style.green_color)).lighter(120)
            border_color = self.STATUS_COLORS.get(status, QColor(style.green_color))
        elif status == 'Atrasado':
            bg_color = self.STATUS_COLORS.get(status, QColor(style.red_color)).lighter(120)
            border_color = self.STATUS_COLORS.get(status, QColor(style.red_color))
        else:
            bg_color = base_color.lighter(140)
            border_color = base_color
        
        # Aplicar cores
        self.setBrush(QBrush(bg_color))
        self.setPen(QPen(border_color, 2))
        
        # Status visual adicional
        if status == 'Atrasado':
            self.setBrush(QBrush(QColor(style.red_color).lighter(170)))
        elif status == 'Em Andamento':
            self.setBrush(QBrush(QColor(style.orange_color).lighter(150)))
        elif status == 'Cancelado':
            self.setBrush(QBrush(QColor('#555555')))
    
    def _add_texts(self):
        """Adiciona textos ao item"""
        rect = self.rect()
        
        # Título
        title_item = QGraphicsTextItem(self)
        title_item.setPlainText(self.item_data.get('title', 'Evento'))
        title_item.setDefaultTextColor(QColor(style.background_color))
        title_item.setPos(rect.left() + 5, rect.top() + 5)
        
        # Ajustar fonte
        font = title_item.font()
        font.setBold(True)
        title_item.setFont(font)
        
        # Horário
        time_text = f"{self.item_data.get('start_time', '00:00')}"
        if self.item_data.get('end_time'):
            time_text += f" - {self.item_data.get('end_time')}"
            
        time_item = QGraphicsTextItem(self)
        time_item.setPlainText(time_text)
        time_item.setDefaultTextColor(QColor(style.background_color))
        time_item.setPos(rect.left() + 5, rect.top() + 25)
        
        # Responsável
        responsible_name = self.item_data.get('responsible_name')
        if responsible_name:
            resp_item = QGraphicsTextItem(self)
            resp_item.setPlainText(f"Resp: {responsible_name}")
            resp_item.setDefaultTextColor(QColor(style.background_color))
            resp_item.setPos(rect.left() + 5, rect.top() + 40)
    
    def update_position(self, new_time_str):
        """Atualiza a posição do item com base no novo horário"""
        try:
            h, m = map(int, new_time_str.split(':'))
            start_minutes = h * 60 + m
            
            # Calcular nova posição X
            x_pos = start_minutes * self.time_scale
            
            # Manter posição Y e dimensões
            rect = self.rect()
            self.setRect(QRectF(x_pos, rect.y(), rect.width(), rect.height()))
            
            # Atualizar dados
            self.item_data['start_time'] = new_time_str
            
            # Recalcular horário de fim se necessário
            if self.item_data.get('end_time'):
                try:
                    h, m = map(int, self.item_data['end_time'].split(':'))
                    end_minutes = h * 60 + m
                    duration_minutes = end_minutes - (h * 60 + m)  # Usar o horário antigo
                    
                    # Calcular novo horário de fim
                    end_minutes = start_minutes + duration_minutes
                    end_h = end_minutes // 60
                    end_m = end_minutes % 60
                    
                    self.item_data['end_time'] = f"{end_h:02d}:{end_m:02d}"
                except (ValueError, AttributeError):
                    pass
        except (ValueError, AttributeError):
            pass
    
    def update_data(self, new_data):
        """Atualiza os dados do item e sua aparência"""
        self.item_data.update(new_data)
        
        # Recalcular geometria
        self._setup_geometry()
        
        # Atualizar aparência
        self._setup_appearance()
        
        # Remover textos existentes
        for child in self.childItems():
            self.scene().removeItem(child)
            
        # Adicionar novos textos
        self._add_texts()
    
    def mousePressEvent(self, event):
        """Manipula o evento de clique do mouse"""
        if event.button() == Qt.LeftButton:
            # Selecionar o item
            self.setSelected(True)
        elif event.button() == Qt.RightButton:
            # Mostrar menu contextual
            menu = QMenu()
            edit_action = QAction("Editar", None)
            change_status_menu = QMenu("Alterar Status")
            
            # Opções de status
            for status in ['Pendente', 'Em Andamento', 'Concluido', 'Atrasado', 'Cancelado']:
                action = QAction(status, None)
                action.triggered.connect(lambda checked, s=status: self.scene().parent().request_status_update(self.item_data['id'], s))
                change_status_menu.addAction(action)
            
            edit_action.triggered.connect(lambda: self.scene().parent().request_edit_item(self.item_data))
            menu.addAction(edit_action)
            menu.addMenu(change_status_menu)
            
            menu.exec_(event.screenPos().toPoint())
        
        super().mousePressEvent(event)
    
    def mouseReleaseEvent(self, event):
        """Manipula o evento de liberação do mouse"""
        if event.button() == Qt.LeftButton and self.isSelected():
            # Calcular novo horário baseado na posição
            x_pos = self.rect().x()
            minutes = int(x_pos / self.time_scale)
            
            hour = minutes // 60
            minute = minutes % 60
            
            # Formatar novo horário
            new_time = f"{hour:02d}:{minute:02d}"
            
            # Notificar mudança de posição
            self.scene().parent().request_move_item(self.item_data['id'], new_time)
            
        super().mouseReleaseEvent(event)


class TimelineView(QGraphicsView):
    """Visualizador customizado para a timeline"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        self.setRenderHint(QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        self.setViewportUpdateMode(QGraphicsView.FullViewportUpdate)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        
        # Criar cena
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        
        # Configurações
        self.hour_width = 100  # Largura de uma hora em pixels (ajustável)
        self.time_scale = self.hour_width / 60  # Pixels por minuto
        
        # Estado atual
        self.timeline_items = {}  # id -> QGraphicsItem
        
        # Setup inicial
        self._draw_grid()
    
    def _draw_grid(self):
        """Desenha a grade de tempo e linhas de seção"""
        self.scene.clear()
        self.timeline_items = {}
        
        # Tamanho total para 24 horas
        width = 24 * self.hour_width
        height = 400  # Altura total para todas as seções
        
        # Definir tamanho da cena
        self.scene.setSceneRect(0, -20, width, height)
        
        # Linhas horizontais para separar tipos
        y_positions = [0, 70, 140, 210, 280, 350]
        section_names = ["Captação", "Preparação", "Edição", "Entregas", "Outros"]
        
        for i, y in enumerate(y_positions[:-1]):
            # Linha horizontal
            self.scene.addLine(0, y, width, y, QPen(QColor(style.current_line_color), 1))
            
            # Rótulo da seção
            text_item = self.scene.addText(section_names[i])
            text_item.setDefaultTextColor(QColor(style.foreground_color))
            text_item.setPos(-20, y + 5)
        
        # Linhas verticais para horas e texto com hora
        for hour in range(25):  # 0 a 24
            x = hour * self.hour_width
            
            # Linha vertical principal
            self.scene.addLine(x, 0, x, height, QPen(QColor(style.current_line_color), 1))
            
            # Texto da hora
            if hour < 24:  # Não mostrar texto para a última linha (24:00)
                text_item = self.scene.addText(f"{hour:02d}:00")
                text_item.setDefaultTextColor(QColor(style.foreground_color))
                text_item.setPos(x + 5, -20)
                
                # Linhas verticais para cada 15 minutos
                for minute in [15, 30, 45]:
                    x_minute = x + (minute * self.time_scale)
                    pen = QPen(QColor(style.current_line_color), 0.5, Qt.DotLine)
                    self.scene.addLine(x_minute, 0, x_minute, height, pen)
    
    def set_time_scale(self, scale_value):
        """Ajusta a escala de tempo
        
        Args:
            scale_value (int): Valor de 1 a 100 para a escala
        """
        # Converter valor de 1-100 para largura em pixels (50-300)
        self.hour_width = 50 + (scale_value / 100) * 250
        self.time_scale = self.hour_width / 60
        
        # Redesenhar grade
        self._draw_grid()
        
        # Recriar itens da timeline
        current_items = self.get_timeline_items()
        
        if current_items:
            self.set_timeline_items(current_items)
    
    def get_timeline_items(self):
        """Retorna os itens atuais da timeline"""
        return {item_id: item.item_data for item_id, item in self.timeline_items.items()}
    
    def set_timeline_items(self, items):
        """Define os itens da timeline
        
        Args:
            items (list): Lista de dicionários com dados dos itens
        """
        # Limpar cena mantendo o grid
        for item_id, item in self.timeline_items.items():
            self.scene.removeItem(item)
            
        self.timeline_items = {}
        
        # Adicionar novos itens
        for item in items:
            timeline_item = TimelineItemWidget(item, self.time_scale)
            self.scene.addItem(timeline_item)
            self.timeline_items[item['id']] = timeline_item
    
    def update_item(self, item_id, new_data):
        """Atualiza um item específico da timeline
        
        Args:
            item_id (str): ID do item
            new_data (dict): Novos dados
        """
        if item_id in self.timeline_items:
            self.timeline_items[item_id].update_data(new_data)
    
    def filter_items(self, filter_type=None, filter_responsible=None):
        """Filtra os itens visíveis da timeline
        
        Args:
            filter_type (str): Tipo para filtrar ou None para todos
            filter_responsible (int): ID do responsável ou None para todos
        """
        for item_id, item in self.timeline_items.items():
            show = True
            
            # Aplicar filtro de tipo
            if filter_type and item.item_data.get('type') != filter_type:
                show = False
                
            # Aplicar filtro de responsável
            if filter_responsible and item.item_data.get('responsible_id') != filter_responsible:
                show = False
                
            # Mostrar ou ocultar o item
            item.setVisible(show)
    
    def wheelEvent(self, event: QWheelEvent):
        """Manipula eventos de rolagem do mouse para zoom"""
        if event.modifiers() & Qt.ControlModifier:
            # Zoom in/out com Ctrl+Roda
            zoom_in = event.angleDelta().y() > 0
            
            if zoom_in:
                self.scale(1.2, 1.2)
            else:
                self.scale(0.8, 0.8)
                
            event.accept()
        else:
            # Comportamento normal de rolagem
            super().wheelEvent(event)


class ItemEditDialog(QDialog):
    """Diálogo para edição de itens da timeline"""
    
    def __init__(self, item_data, team_repo, parent=None):
        super().__init__(parent)
        
        self.item_data = item_data.copy()
        self.team_repo = team_repo
        self.team_members = []
        
        self.setup_ui()
        self.load_data()
    
    def setup_ui(self):
        """Configura a interface do diálogo"""
        self.setWindowTitle("Editar Item da Timeline")
        self.setMinimumWidth(400)
        
        layout = QVBoxLayout(self)
        
        form_layout = QFormLayout()
        
        # Título
        self.title_edit = QLineEdit()
        self.title_edit.setStyleSheet(style.input_style)
        form_layout.addRow("Título:", self.title_edit)
        
        # Horários
        time_layout = QHBoxLayout()
        
        self.start_time = QTimeEdit()
        self.start_time.setStyleSheet(style.input_style)
        self.start_time.setDisplayFormat("HH:mm")
        
        self.end_time = QTimeEdit()
        self.end_time.setStyleSheet(style.input_style)
        self.end_time.setDisplayFormat("HH:mm")
        
        time_layout.addWidget(self.start_time)
        time_layout.addWidget(QLabel("até"))
        time_layout.addWidget(self.end_time)
        
        form_layout.addRow("Horário:", time_layout)
        
        # Tipo
        self.type_combo = QComboBox()
        self.type_combo.setStyleSheet(style.combobox_style)
        self.type_combo.addItems(['captacao', 'edicao', 'entrega', 'preparacao', 'outro'])
        form_layout.addRow("Tipo:", self.type_combo)
        
        # Status
        self.status_combo = QComboBox()
        self.status_combo.setStyleSheet(style.combobox_style)
        self.status_combo.addItems(['Pendente', 'Em Andamento', 'Concluido', 'Atrasado', 'Cancelado'])
        form_layout.addRow("Status:", self.status_combo)
        
        # Responsável
        self.responsible_combo = QComboBox()
        self.responsible_combo.setStyleSheet(style.combobox_style)
        self.load_team_members()
        form_layout.addRow("Responsável:", self.responsible_combo)
        
        # Notas
        self.notes_edit = QTextEdit()
        self.notes_edit.setStyleSheet(style.input_style)
        self.notes_edit.setMaximumHeight(100)
        form_layout.addRow("Notas:", self.notes_edit)
        
        layout.addLayout(form_layout)
        
        # Botões
        buttons_layout = QHBoxLayout()
        
        self.save_btn = QPushButton("Salvar")
        self.save_btn.setStyleSheet(style.btn_primary)
        self.save_btn.clicked.connect(self.accept)
        
        self.cancel_btn = QPushButton("Cancelar")
        self.cancel_btn.setStyleSheet(style.btn_secondary)
        self.cancel_btn.clicked.connect(self.reject)
        
        buttons_layout.addStretch()
        buttons_layout.addWidget(self.save_btn)
        buttons_layout.addWidget(self.cancel_btn)
        
        layout.addLayout(buttons_layout)
    
    def load_team_members(self):
        """Carrega os membros da equipe no combo"""
        self.responsible_combo.clear()
        self.responsible_combo.addItem("Sem responsável", None)
        
        # Carregar todos os usuários
        users = self.team_repo.get_all_users()
        self.team_members = users
        
        for user in users:
            self.responsible_combo.addItem(user.get('name', ''), user.get('id'))
    
    def load_data(self):
        """Carrega os dados do item nos campos"""
        self.title_edit.setText(self.item_data.get('title', ''))
        
        # Horários
        if self.item_data.get('start_time'):
            try:
                h, m = map(int, self.item_data['start_time'].split(':'))
                self.start_time.setTime(QTime(h, m))
            except (ValueError, AttributeError):
                pass
        
        if self.item_data.get('end_time'):
            try:
                h, m = map(int, self.item_data['end_time'].split(':'))
                self.end_time.setTime(QTime(h, m))
            except (ValueError, AttributeError):
                pass
        
        # Tipo
        index = self.type_combo.findText(self.item_data.get('type', ''))
        if index >= 0:
            self.type_combo.setCurrentIndex(index)
        
        # Status
        index = self.status_combo.findText(self.item_data.get('status', ''))
        if index >= 0:
            self.status_combo.setCurrentIndex(index)
        
        # Responsável
        if self.item_data.get('responsible_id'):
            index = self.responsible_combo.findData(self.item_data['responsible_id'])
            if index >= 0:
                self.responsible_combo.setCurrentIndex(index)
        
        # Notas
        self.notes_edit.setText(self.item_data.get('notes', ''))
    
    def get_updated_data(self):
        """Retorna os dados atualizados"""
        return {
            'title': self.title_edit.text(),
            'start_time': self.start_time.time().toString("HH:mm"),
            'end_time': self.end_time.time().toString("HH:mm"),
            'type': self.type_combo.currentText(),
            'status': self.status_combo.currentText(),
            'responsible_id': self.responsible_combo.currentData(),
            'notes': self.notes_edit.toPlainText()
        }


class ConflictDialog(QDialog):
    """Diálogo para exibir conflitos na timeline"""
    
    def __init__(self, conflicts, parent=None):
        super().__init__(parent)
        
        self.conflicts = conflicts
        self.setup_ui()
    
    def setup_ui(self):
        """Configura a interface do diálogo"""
        self.setWindowTitle("Conflitos Detectados na Timeline")
        self.setMinimumWidth(500)
        
        layout = QVBoxLayout(self)
        
        # Título
        title = QLabel("Os seguintes conflitos foram detectados:")
        title.setStyleSheet(f"font-weight: bold; color: {style.red_color};")
        layout.addWidget(title)
        
        # Lista de conflitos
        for i, conflict in enumerate(self.conflicts):
            conflict_frame = QFrame()
            conflict_frame.setFrameShape(QFrame.StyledPanel)
            conflict_frame.setStyleSheet(f"""
                QFrame {{
                    background-color: {style.BG_THREE};
                    border: 1px solid {style.red_color};
                    border-radius: 5px;
                    padding: 5px;
                    margin-bottom: 5px;
                }}
            """)
            
            conflict_layout = QVBoxLayout(conflict_frame)
            
            if conflict.get('type') == 'responsible_overlap':
                # Conflito de sobreposição de responsáveis
                header = QLabel(f"Conflito #{i+1}: Sobreposição de Horários")
                header.setStyleSheet(f"font-weight: bold; color: {style.red_color};")
                
                resp = QLabel(f"Responsável: {conflict.get('responsible_name', 'Não especificado')}")
                resp.setStyleSheet(f"color: {style.foreground_color};")
                
                events_text = ""
                for event in conflict.get('events', []):
                    events_text += f"• {event.get('title')} ({event.get('time')})\n"
                
                events = QLabel(events_text)
                events.setStyleSheet(f"color: {style.foreground_color};")
                
                conflict_layout.addWidget(header)
                conflict_layout.addWidget(resp)
                conflict_layout.addWidget(events)
                
            elif conflict.get('type') == 'delivery_without_edit':
                # Entrega sem edição prévia
                header = QLabel(f"Conflito #{i+1}: Entrega sem Edição")
                header.setStyleSheet(f"font-weight: bold; color: {style.red_color};")
                
                event = conflict.get('event', {})
                event_info = QLabel(f"Evento: {event.get('title')} às {event.get('time')}")
                event_info.setStyleSheet(f"color: {style.foreground_color};")
                
                description = QLabel("Esta entrega não possui um evento de edição associado antes dela.")
                description.setStyleSheet(f"color: {style.foreground_color};")
                description.setWordWrap(True)
                
                conflict_layout.addWidget(header)
                conflict_layout.addWidget(event_info)
                conflict_layout.addWidget(description)
            
            layout.addWidget(conflict_frame)
        
        # Botão para fechar
        self.close_btn = QPushButton("Fechar")
        self.close_btn.setStyleSheet(style.btn_primary)
        self.close_btn.clicked.connect(self.accept)
        
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()
        btn_layout.addWidget(self.close_btn)
        
        layout.addLayout(btn_layout)


class TimelineWidget(QWidget):
    """Widget principal para visualização e manipulação da timeline"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        self.timeline_repo = TimelineRepository()
        self.event_repo = EventRepository()
        self.team_repo = TeamRepository()
        
        self.logger = get_logger()
        
        # Estado atual
        self.current_event_id = None
        self.current_items = []
        
        # Inicializar UI
        self.init_ui()
        
    def init_ui(self):
        """Inicializa a interface de usuário"""
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        
        # Cabeçalho
        header_layout = QHBoxLayout()
        
        title_label = QLabel("Timeline")
        title_label.setStyleSheet(f"font-size: 18pt; color: {style.foreground_color};")
        
        # Seletor de evento
        event_layout = QHBoxLayout()
        event_label = QLabel("Evento:")
        
        self.event_selector = QComboBox()
        self.event_selector.setMinimumWidth(250)
        self.event_selector.setStyleSheet(style.combobox_style)
        self.event_selector.currentIndexChanged.connect(self.on_event_changed)
        
        event_layout.addWidget(event_label)
        event_layout.addWidget(self.event_selector)
        event_layout.addStretch()
        
        header_layout.addWidget(title_label)
        header_layout.addStretch()
        header_layout.addLayout(event_layout)
        
        # Controles
        controls_layout = QHBoxLayout()
        
        # Botão para gerar/atualizar timeline
        self.generate_btn = QPushButton("Gerar/Atualizar Timeline")
        self.generate_btn.setStyleSheet(style.btn_primary)
        self.generate_btn.setIcon(QIcon("./resources/icons/refresh.svg"))
        self.generate_btn.clicked.connect(self.generate_timeline)
        
        # Botão para verificar conflitos
        self.check_conflicts_btn = QPushButton("Verificar Conflitos")
        self.check_conflicts_btn.setStyleSheet(style.btn_secondary)
        self.check_conflicts_btn.setIcon(QIcon("./resources/icons/alert.svg"))
        self.check_conflicts_btn.clicked.connect(self.check_conflicts)
        
        # Controle de zoom
        zoom_layout = QHBoxLayout()
        zoom_label = QLabel("Zoom:")
        
        self.zoom_slider = QSlider(Qt.Horizontal)
        self.zoom_slider.setMinimum(0)
        self.zoom_slider.setMaximum(100)
        self.zoom_slider.setValue(50)  # Valor inicial
        self.zoom_slider.setStyleSheet("""
            QSlider::groove:horizontal {
                height: 4px;
                background: #44475A;
                margin: 0px;
                border-radius: 2px;
            }
            QSlider::handle:horizontal {
                background: #BD93F9;
                border: 0px;
                width: 16px;
                margin: -6px 0;
                border-radius: 8px;
            }
        """)
        self.zoom_slider.valueChanged.connect(self.on_zoom_changed)
        
        zoom_layout.addWidget(zoom_label)
        zoom_layout.addWidget(self.zoom_slider)
        
        # Filtros
        filter_layout = QHBoxLayout()
        filter_label = QLabel("Filtros:")
        
        # Filtro por tipo
        self.tipo_combo = QComboBox()
        self.tipo_combo.setStyleSheet(style.combobox_style)
        self.tipo_combo.addItem("Todos os tipos", None)
        self.tipo_combo.addItem("Captação", "captacao")
        self.tipo_combo.addItem("Edição", "edicao")
        self.tipo_combo.addItem("Entrega", "entrega")
        self.tipo_combo.addItem("Preparação", "preparacao")
        self.tipo_combo.addItem("Outro", "outro")
        self.tipo_combo.currentIndexChanged.connect(self.apply_filters)
        
        # Filtro por responsável
        self.resp_combo = QComboBox()
        self.resp_combo.setStyleSheet(style.combobox_style)
        self.resp_combo.addItem("Todos os responsáveis", None)
        self.resp_combo.currentIndexChanged.connect(self.apply_filters)
        
        filter_layout.addWidget(filter_label)
        filter_layout.addWidget(self.tipo_combo)
        filter_layout.addWidget(self.resp_combo)
        
        # Adicionar ao layout de controles
        controls_layout.addWidget(self.generate_btn)
        controls_layout.addWidget(self.check_conflicts_btn)
        controls_layout.addStretch()
        controls_layout.addLayout(zoom_layout)
        
        # Visualizador da timeline
        self.timeline_view = TimelineView()
        self.timeline_view.setMinimumHeight(400)
        
        # Layout inferior para filtros
        bottom_layout = QHBoxLayout()
        bottom_layout.addLayout(filter_layout)
        bottom_layout.addStretch()
        
        # Adicionar tudo ao layout principal
        main_layout.addLayout(header_layout)
        main_layout.addLayout(controls_layout)
        main_layout.addWidget(self.timeline_view)
        main_layout.addLayout(bottom_layout)
        
        # Timer para atualização periódica
        self.update_timer = QTimer(self)
        self.update_timer.setInterval(60000)  # 1 minuto
        self.update_timer.timeout.connect(self.check_overdue_items)
        self.update_timer.start()
        
        # Carregar dados iniciais
        self.load_events()
    
    def load_events(self):
        """Carrega os eventos disponíveis no seletor"""
        try:
            events = self.event_repo.get_all()
            self.event_selector.clear()
            
            if events:
                for event in events:
                    self.event_selector.addItem(event["name"], event["id"])
                    
        except Exception as e:
            self.logger.error(f"Erro ao carregar eventos: {e}")
            QMessageBox.critical(self, "Erro", f"Erro ao carregar eventos: {str(e)}")
    
    def on_event_changed(self, index):
        """Manipula a mudança do evento selecionado"""
        if index < 0:
            return
            
        event_id = self.event_selector.currentData()
        self.current_event_id = event_id
        
        # Carregar timeline do evento
        self.load_timeline(event_id)
        
        # Carregar responsáveis
        self.load_responsibles(event_id)
    
    def load_timeline(self, event_id):
        """Carrega a timeline para o evento selecionado"""
        try:
            items = self.timeline_repo.get_timeline_by_event(event_id)
            self.current_items = items
            
            if items:
                self.timeline_view.set_timeline_items(items)
                
                # Verificar se há conflitos ao carregar
                conflicts = self.timeline_repo.check_conflicts(event_id)
                if conflicts:
                    self.show_conflict_warning(len(conflicts))
            else:
                self.timeline_view.set_timeline_items([])
                
        except Exception as e:
            self.logger.error(f"Erro ao carregar timeline: {e}")
            QMessageBox.critical(self, "Erro", f"Erro ao carregar timeline: {str(e)}")
    
    def load_responsibles(self, event_id):
        """Carrega os responsáveis associados ao evento"""
        try:
            self.resp_combo.clear()
            self.resp_combo.addItem("Todos os responsáveis", None)
            
            # Adicionar membros da equipe
            team_members = self.team_repo.get_event_team(event_id)
            if team_members:
                for member in team_members:
                    self.resp_combo.addItem(member["name"], member["id"])
                    
        except Exception as e:
            self.logger.error(f"Erro ao carregar responsáveis: {e}")
    
    def on_zoom_changed(self, value):
        """Manipula a mudança do zoom"""
        self.timeline_view.set_time_scale(value)
    
    def generate_timeline(self):
        """Gera ou atualiza a timeline a partir do briefing"""
        if not self.current_event_id:
            QMessageBox.warning(self, "Aviso", "Selecione um evento primeiro.")
            return
            
        try:
            # Confirmar se deseja sobrescrever a timeline existente
            if self.current_items:
                reply = QMessageBox.question(
                    self, 
                    "Confirmar Atualização",
                    "A timeline existente será substituída. Deseja continuar?",
                    QMessageBox.Yes | QMessageBox.No,
                    QMessageBox.No
                )
                
                if reply != QMessageBox.Yes:
                    return
            
            # Gerar timeline
            success = self.timeline_repo.generate_timeline_from_briefing(self.current_event_id)
            
            if success:
                QMessageBox.information(
                    self, "Sucesso", "Timeline gerada com sucesso!"
                )
                # Recarregar a timeline
                self.load_timeline(self.current_event_id)
            else:
                QMessageBox.critical(
                    self, "Erro", 
                    "Não foi possível gerar a timeline. Verifique se existe um briefing para este evento."
                )
                
        except Exception as e:
            self.logger.error(f"Erro ao gerar timeline: {e}")
            QMessageBox.critical(self, "Erro", f"Erro ao gerar timeline: {str(e)}")
    
    def check_conflicts(self):
        """Verifica conflitos na timeline atual"""
        if not self.current_event_id:
            QMessageBox.warning(self, "Aviso", "Selecione um evento primeiro.")
            return
            
        try:
            conflicts = self.timeline_repo.check_conflicts(self.current_event_id)
            
            if conflicts:
                # Mostrar diálogo com detalhes dos conflitos
                dialog = ConflictDialog(conflicts, self)
                dialog.exec_()
            else:
                QMessageBox.information(
                    self, "Verificação Concluída", "Não foram encontrados conflitos na timeline."
                )
                
        except Exception as e:
            self.logger.error(f"Erro ao verificar conflitos: {e}")
            QMessageBox.critical(self, "Erro", f"Erro ao verificar conflitos: {str(e)}")
    
    def apply_filters(self):
        """Aplica os filtros selecionados à timeline"""
        tipo = self.tipo_combo.currentData()
        responsavel = self.resp_combo.currentData()
        
        self.timeline_view.filter_items(tipo, responsavel)
    
    def check_overdue_items(self):
        """Verifica e atualiza itens atrasados"""
        if not self.current_event_id or not self.current_items:
            return
            
        try:
            # Obter hora atual
            now = datetime.now()
            current_time_str = now.strftime("%H:%M")
            
            # Verificar cada item
            for item in self.current_items:
                if (item["status"] not in ["Concluido", "Cancelado", "Atrasado"] and 
                    item["start_time"] and item["start_time"] < current_time_str):
                    
                    # Marcar como atrasado
                    self.timeline_repo.update_timeline_item(
                        item["id"], {"status": "Atrasado"}
                    )
                    
                    # Atualizar na interface
                    self.timeline_view.update_item(
                        item["id"], {"status": "Atrasado"}
                    )
            
        except Exception as e:
            self.logger.error(f"Erro ao verificar itens atrasados: {e}")
    
    def show_conflict_warning(self, conflict_count):
        """Mostra aviso sobre conflitos detectados"""
        self.logger.info(f"Detectados {conflict_count} conflitos na timeline")
        
        # Mostrar barra de aviso
        from PySide6.QtWidgets import QToolTip
        QToolTip.showText(
            self.check_conflicts_btn.mapToGlobal(QPoint(0, 0)),
            f"Atenção: {conflict_count} conflitos detectados! Clique para ver detalhes.",
            self.check_conflicts_btn,
            QRect(),
            5000  # tempo em ms
        )
    
    def request_move_item(self, item_id, new_time):
        """Solicita movimentação de um item na timeline
        
        Args:
            item_id (str): ID do item
            new_time (str): Novo horário de início
        """
        try:
            # Atualizar no repositório
            success = self.timeline_repo.update_timeline_item(
                item_id, {"start_time": new_time}
            )
            
            if success:
                # Atualizar visualmente
                for item in self.current_items:
                    if item["id"] == item_id:
                        item["start_time"] = new_time
                        break
                        
                self.logger.info(f"Item {item_id} movido para {new_time}")
                
                # Verificar conflitos após movimento
                conflicts = self.timeline_repo.check_conflicts(self.current_event_id)
                if conflicts:
                    self.show_conflict_warning(len(conflicts))
            else:
                # Recarregar para reverter a movimentação visual
                self.load_timeline(self.current_event_id)
                
        except Exception as e:
            self.logger.error(f"Erro ao mover item: {e}")
            QMessageBox.critical(self, "Erro", f"Erro ao mover item: {str(e)}")
            
            # Recarregar para reverter a movimentação visual
            self.load_timeline(self.current_event_id)
    
    def request_edit_item(self, item_data):
        """Solicita edição de um item da timeline
        
        Args:
            item_data (dict): Dados do item a ser editado
        """
        try:
            dialog = ItemEditDialog(item_data, self.team_repo, self)
            
            if dialog.exec_() == QDialog.Accepted:
                # Obter dados atualizados
                updated_data = dialog.get_updated_data()
                
                # Atualizar no repositório
                success = self.timeline_repo.update_timeline_item(
                    item_data["id"], updated_data
                )
                
                if success:
                    # Atualizar visualmente
                    self.timeline_view.update_item(item_data["id"], updated_data)
                    
                    # Atualizar nos dados atuais
                    for item in self.current_items:
                        if item["id"] == item_data["id"]:
                            item.update(updated_data)
                            break
                            
                    self.logger.info(f"Item {item_data['id']} editado com sucesso")
                    
                    # Verificar conflitos após edição
                    conflicts = self.timeline_repo.check_conflicts(self.current_event_id)
                    if conflicts:
                        self.show_conflict_warning(len(conflicts))
                else:
                    QMessageBox.warning(self, "Aviso", "Não foi possível salvar as alterações.")
                    
        except Exception as e:
            self.logger.error(f"Erro ao editar item: {e}")
            QMessageBox.critical(self, "Erro", f"Erro ao editar item: {str(e)}")
    
    def request_status_update(self, item_id, new_status):
        """Solicita atualização de status de um item
        
        Args:
            item_id (str): ID do item
            new_status (str): Novo status
        """
        try:
            # Atualizar no repositório
            success = self.timeline_repo.update_timeline_item(
                item_id, {"status": new_status}
            )
            
            if success:
                # Atualizar visualmente
                self.timeline_view.update_item(item_id, {"status": new_status})
                
                # Atualizar nos dados atuais
                for item in self.current_items:
                    if item["id"] == item_id:
                        item["status"] = new_status
                        break
                        
                self.logger.info(f"Status do item {item_id} alterado para {new_status}")
                
            else:
                QMessageBox.warning(self, "Aviso", "Não foi possível atualizar o status.")
                
        except Exception as e:
            self.logger.error(f"Erro ao atualizar status: {e}")
            QMessageBox.critical(self, "Erro", f"Erro ao atualizar status: {str(e)}")

























## 3. Instruções para Integração ao Projeto

### 3.1 Script de Inicialização para Criação de Tabelas

```python name=database/init_db.py
import os
import sqlite3
import sys

# Adicionar diretório pai ao path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from database.schema.create_briefing_tables import create_briefing_tables
from database.schema.create_timeline_tables import create_timeline_tables
from utils.logger import get_logger

logger = get_logger()

def init_database():
    """Inicializa o banco de dados com todas as tabelas necessárias"""
    
    db_path = "database/gonetwork.db"
    
    try:
        # Verificar se o diretório database existe
        os.makedirs(os.path.dirname(db_path), exist_ok=True)
        
        # Criar tabelas de briefing
        create_briefing_tables(db_path)
        
        # Criar tabelas de timeline
        create_timeline_tables(db_path)
        
        logger.info(f"Banco de dados inicializado com sucesso: {db_path}")
        return True
        
    except Exception as e:
        logger.error(f"Erro ao inicializar banco de dados: {e}")
        return False


if __name__ == "__main__":
    init_database()
```

### 3.2 Integração aos Arquivos Principais

Para integrar as novas abas corretamente à aplicação principal, devemos garantir que a instância de `MainWindow` carregue e use corretamente os novos widgets e repositórios:

```python name=gui/main_window.py
# Adicionar importações no topo do arquivo
from gui.widgets.briefing_widget import BriefingWidget
from gui.widgets.timeline_widget import TimelineWidget
from database.BriefingRepository import BriefingRepository
from database.TimelineRepository import TimelineRepository

# Na classe MainWindow, modificar o método setup_app_widget para incluir os novos widgets
def setup_app_widget(self):
    # Código existente...
    
    # Adicionar os novos widgets
    self.briefing_page = BriefingWidget()
    self.timeline_page = TimelineWidget()
    
    # Conectar sinal de timeline_gerada do BriefingWidget para exibir a aba Timeline
    self.briefing_page.timeline_gerada.connect(self.switch_to_timeline)
    
    # Adicionar ao QStackedWidget (presumidamente na posição adequada)
    self.pages.addWidget(self.briefing_page)
    self.pages.addWidget(self.timeline_page)
    
    # Restante do código existente...

# Adicionar método para mudar para a aba Timeline quando uma timeline for gerada
def switch_to_timeline(self, event_id):
    """Troca para a aba Timeline e carrega o evento especificado"""
    # Encontrar índice da aba timeline
    timeline_index = -1
    for i in range(self.pages.count()):
        if isinstance(self.pages.widget(i), TimelineWidget):
            timeline_index = i
            break
    
    if timeline_index >= 0:
        # Selecionar a aba
        self.show_page(timeline_index)
        
        # Selecionar o evento no combobox da timeline
        timeline_widget = self.pages.widget(timeline_index)
        for i in range(timeline_widget.event_selector.count()):
            if timeline_widget.event_selector.itemData(i) == event_id:
                timeline_widget.event_selector.setCurrentIndex(i)
                break










## 3.3 Scripts de Teste e Validação (Revisado)

### 3.3.1 Teste da Aba Briefing

```python name=tests/test_briefing.py
import sys
import os
import unittest
from datetime import datetime, timedelta
import json

# Adicionar diretório pai ao path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from database.BriefingRepository import BriefingRepository
from database.EventRepository import EventRepository
from database.TeamRepository import TeamRepository


class TestBriefing(unittest.TestCase):
    
    def setUp(self):
        """Configuração inicial para os testes"""
        self.briefing_repo = BriefingRepository()
        self.event_repo = EventRepository()
        self.team_repo = TeamRepository()
        
        # Criar um evento de teste
        self.test_event_data = {
            "name": "Evento de Teste (Briefing)",
            "start_date": datetime.now().strftime("%Y-%m-%d"),
            "end_date": (datetime.now() + timedelta(days=1)).strftime("%Y-%m-%d"),
            "location": "Local de Teste",
            "description": "Descrição de teste"
        }
        
        self.event_id = self.event_repo.create_event(self.test_event_data)
        
        # Dados para testes de briefing
        self.briefing_data = {
            "info_geral": "Informações gerais do evento de teste",
            "estilo_referencias": "Estilo e referências de teste",
            "patrocinadores": [
                {
                    "nome": "Patrocinador Teste 1",
                    "horario": "10:00",
                    "horario_livre": False,
                    "responsavel_id": None,
                    "realtime": True,
                    "realtime_horario": "12:00",
                    "editor_id": None,
                    "orientacoes": "Orientações de teste 1"
                },
                {
                    "nome": "Patrocinador Teste 2",
                    "horario": "14:00",
                    "horario_livre": False,
                    "responsavel_id": None,
                    "realtime": False,
                    "realtime_horario": "",
                    "editor_id": None,
                    "orientacoes": "Orientações de teste 2"
                }
            ],
            "programacao_palcos": [
                {
                    "palco": "Palco Principal",
                    "artista": "Artista Teste 1",
                    "horario_inicio": "15:00",
                    "horario_fim": "16:30",
                    "observacoes": "Observações de teste 1"
                },
                {
                    "palco": "Palco Secundário",
                    "artista": "Artista Teste 2",
                    "horario_inicio": "17:00",
                    "horario_fim": "18:00",
                    "observacoes": "Observações de teste 2"
                }
            ],
            "entregas_realtime": [
                {
                    "titulo": "Entrega Teste 1",
                    "hora": "13:00",
                    "editor_id": None,
                    "plataforma": "Instagram",
                    "orientacoes": "Orientações de entrega 1"
                }
            ],
            "entregas_pos_evento": {
                "deadline": (datetime.now() + timedelta(days=7)).strftime("%Y-%m-%d"),
                "pacotes": ["Aftermovie", "Highlights", "Teaser"],
                "observacoes": "Observações pós-evento de teste"
            }
        }
    
    def tearDown(self):
        """Limpeza após os testes"""
        # Remover briefing de teste
        if hasattr(self, "briefing_id") and self.briefing_id:
            self.briefing_repo.db.execute("DELETE FROM briefing_items WHERE briefing_id = ?", (self.briefing_id,))
            self.briefing_repo.db.execute("DELETE FROM briefings WHERE id = ?", (self.briefing_id,))
        
        # Remover evento de teste
        if self.event_id:
            self.event_repo.delete_event(self.event_id)
    
    def test_create_briefing(self):
        """Testa a criação de um briefing"""
        # Criar briefing
        self.briefing_id = self.briefing_repo.create_or_update_briefing(
            self.event_id, self.briefing_data
        )
        
        # Verificar se foi criado
        self.assertIsNotNone(self.briefing_id)
        
        # Verificar se podemos recuperar o briefing
        briefing = self.briefing_repo.get_briefing_by_event(self.event_id)
        self.assertIsNotNone(briefing)
    
    def test_update_briefing(self):
        """Testa a atualização de um briefing"""
        # Criar briefing
        self.briefing_id = self.briefing_repo.create_or_update_briefing(
            self.event_id, self.briefing_data
        )
        
        # Modificar dados
        updated_data = self.briefing_data.copy()
        updated_data["info_geral"] = "Informações atualizadas"
        updated_data["patrocinadores"].append({
            "nome": "Novo Patrocinador",
            "horario": "09:00",
            "horario_livre": False,
            "responsavel_id": None,
            "realtime": False,
            "realtime_horario": "",
            "editor_id": None,
            "orientacoes": "Orientações do novo"
        })
        
        # Atualizar briefing
        updated_id = self.briefing_repo.create_or_update_briefing(
            self.event_id, updated_data
        )
        
        # Verificar que o ID permanece o mesmo
        self.assertEqual(self.briefing_id, updated_id)
        
        # Verificar se foi atualizado
        briefing = self.briefing_repo.get_briefing_by_event(self.event_id)
        self.assertEqual(briefing["info_geral"], "Informações atualizadas")
        self.assertEqual(len(briefing["patrocinadores"]), 3)
    
    def test_get_briefing_items_by_type(self):
        """Testa a obtenção de itens de briefing por tipo"""
        # Criar briefing
        self.briefing_id = self.briefing_repo.create_or_update_briefing(
            self.event_id, self.briefing_data
        )
        
        # Obter itens por tipo
        patrocinadores = self.briefing_repo.get_briefing_items_by_type(
            self.briefing_id, "patrocinadores"
        )
        
        # Verificar se os dados foram recuperados corretamente
        self.assertIsInstance(patrocinadores, list)
        self.assertEqual(len(patrocinadores), 2)
        self.assertEqual(patrocinadores[0]["nome"], "Patrocinador Teste 1")


if __name__ == "__main__":
    unittest.main()
```

### 3.3.2 Teste da Aba Timeline

```python name=tests/test_timeline.py
import sys
import os
import unittest
from datetime import datetime, timedelta

# Adicionar diretório pai ao path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from database.BriefingRepository import BriefingRepository
from database.EventRepository import EventRepository
from database.TimelineRepository import TimelineRepository
from database.TeamRepository import TeamRepository


class TestTimeline(unittest.TestCase):
    
    def setUp(self):
        """Configuração inicial para os testes"""
        self.briefing_repo = BriefingRepository()
        self.event_repo = EventRepository()
        self.timeline_repo = TimelineRepository()
        self.team_repo = TeamRepository()
        
        # Criar um evento de teste
        self.test_event_data = {
            "name": "Evento de Teste (Timeline)",
            "start_date": datetime.now().strftime("%Y-%m-%d"),
            "end_date": (datetime.now() + timedelta(days=1)).strftime("%Y-%m-%d"),
            "location": "Local de Teste",
            "description": "Descrição de teste"
        }
        
        self.event_id = self.event_repo.create_event(self.test_event_data)
        
        # Criar equipe para o evento
        self.editor_id = self._create_test_user("Editor Teste", "editor")
        self.team_repo.add_user_to_event(self.editor_id, self.event_id, "editor")
        
        # Dados para testes de briefing
        self.briefing_data = {
            "info_geral": "Informações gerais do evento de teste",
            "estilo_referencias": "Estilo e referências de teste",
            "patrocinadores": [
                {
                    "nome": "Patrocinador Timeline 1",
                    "horario": "10:00",
                    "horario_livre": False,
                    "responsavel_id": self.editor_id, # Usar ID criado
                    "realtime": True,
                    "realtime_horario": "12:00",
                    "editor_id": self.editor_id, # Usar ID criado
                    "orientacoes": "Orientações de teste 1"
                }
            ],
            "programacao_palcos": [
                {
                    "palco": "Palco Timeline",
                    "artista": "Artista Timeline",
                    "horario_inicio": "15:00",
                    "horario_fim": "16:30",
                    "observacoes": "Observações de teste"
                }
            ],
            "entregas_realtime": [
                {
                    "titulo": "Entrega Timeline",
                    "hora": "13:00",
                    "editor_id": self.editor_id, # Usar ID criado
                    "plataforma": "Instagram",
                    "orientacoes": "Orientações de entrega timeline"
                }
            ],
            "entregas_pos_evento": {
                "deadline": (datetime.now() + timedelta(days=7)).strftime("%Y-%m-%d"),
                "pacotes": ["Aftermovie", "Highlights"],
                "observacoes": "Observações pós-evento timeline"
            }
        }
        
        # Criar o briefing
        self.briefing_id = self.briefing_repo.create_or_update_briefing(
            self.event_id, self.briefing_data
        )
    
    def _create_test_user(self, name, role):
        """Cria um usuário de teste para os testes"""
        import uuid
        import hashlib
        
        user_id = str(uuid.uuid4())
        salt = str(uuid.uuid4())
        password = hashlib.sha256(("password" + salt).encode()).hexdigest()
        
        self.team_repo.db.execute(
            """
            INSERT INTO users (id, username, email, full_name, role, password_hash, salt, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """,
            (user_id, f"test_{role}", f"{role}@test.com", name, role, password, salt, datetime.now().isoformat())
        )
        
        return user_id
    
    def tearDown(self):
        """Limpeza após os testes"""
        # Remover timeline de teste
        self.timeline_repo.db.execute("DELETE FROM timeline_events WHERE event_id = ?", (self.event_id,))
        
        # Remover briefing de teste
        if hasattr(self, "briefing_id") and self.briefing_id:
            self.briefing_repo.db.execute("DELETE FROM briefing_items WHERE briefing_id = ?", (self.briefing_id,))
            self.briefing_repo.db.execute("DELETE FROM briefings WHERE id = ?", (self.briefing_id,))
        
        # Remover membros da equipe
        self.team_repo.db.execute("DELETE FROM event_team WHERE event_id = ?", (self.event_id,))
        
        # Remover usuários de teste
        if hasattr(self, "editor_id"):
            self.team_repo.db.execute("DELETE FROM users WHERE id = ?", (self.editor_id,))
        
        # Remover evento de teste
        if self.event_id:
            self.event_repo.delete_event(self.event_id)
    
    def test_generate_timeline(self):
        """Testa a geração de uma timeline a partir de um briefing"""
        # Gerar timeline
        result = self.timeline_repo.generate_timeline_from_briefing(self.event_id)
        self.assertTrue(result)
        
        # Verificar se timeline foi gerada
        timeline_events = self.timeline_repo.get_timeline_by_event(self.event_id)
        self.assertIsNotNone(timeline_events)
        self.assertGreater(len(timeline_events), 0)
        
        # Verificar conteúdo
        event_types = [event["type"] for event in timeline_events]
        self.assertIn("captacao", event_types)
        self.assertIn("entrega", event_types)
    
    def test_update_timeline_item(self):
        """Testa a atualização de um item da timeline"""
        # Gerar timeline
        self.timeline_repo.generate_timeline_from_briefing(self.event_id)
        
        # Obter itens
        timeline_events = self.timeline_repo.get_timeline_by_event(self.event_id)
        self.assertGreater(len(timeline_events), 0)
        
        # Pegar primeiro item
        first_item = timeline_events[0]
        item_id = first_item["id"]
        
        # Atualizar status
        update_data = {"status": "Em Andamento"}
        result = self.timeline_repo.update_timeline_item(item_id, update_data)
        self.assertTrue(result)
        
        # Verificar atualização
        updated_events = self.timeline_repo.get_timeline_by_event(self.event_id)
        updated_item = None
        for event in updated_events:
            if event["id"] == item_id:
                updated_item = event
                break
                
        self.assertIsNotNone(updated_item)
        self.assertEqual(updated_item["status"], "Em Andamento")
    
    def test_check_conflicts(self):
        """Testa a detecção de conflitos na timeline"""
        # Gerar timeline
        self.timeline_repo.generate_timeline_from_briefing(self.event_id)
        
        # Obter itens
        timeline_events = self.timeline_repo.get_timeline_by_event(self.event_id)
        
        # Forçar um conflito (mesmo responsável em horários sobrepostos)
        if len(timeline_events) >= 2:
            # Obter dois itens distintos
            item1 = timeline_events[0]
            item2 = timeline_events[1]
            
            # Definir mesmo responsável
            self.timeline_repo.update_timeline_item(
                item1["id"], 
                {"responsible_id": self.editor_id}
            )
            
            self.timeline_repo.update_timeline_item(
                item2["id"], 
                {"responsible_id": self.editor_id}
            )
            
            # Forçar sobreposição de horário
            self.timeline_repo.update_timeline_item(
                item2["id"], 
                {"start_time": item1["start_time"]}
            )
            
            # Verificar conflitos
            conflicts = self.timeline_repo.check_conflicts(self.event_id)
            self.assertGreater(len(conflicts), 0)


if __name__ == "__main__":
    unittest.main()
```

### 3.3.3 Script de Diagnóstico para Briefing

```python name=diagnostico_melhorado_briefing.py
import os
import sys
import sqlite3
from datetime import datetime

# Adicionar diretório pai ao path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from database.Database import Database
from database.BriefingRepository import BriefingRepository
from database.EventRepository import EventRepository


def run_briefing_diagnostics():
    """Executa diagnósticos na implementação da aba Briefing"""
    
    print("\n🔍 Executando diagnóstico da Aba BRIEFING...\n")
    
    # Verificar estrutura do banco de dados
    check_database_structure()
    
    # Verificar repositório de briefing
    check_briefing_repository()
    
    # Verificar integração com eventos
    check_event_integration()
    
    print("\n✅ Diagnóstico da Aba BRIEFING concluído!\n")


def check_database_structure():
    """Verifica a estrutura do banco de dados para briefings"""
    try:
        print("📊 Verificando estrutura do banco de dados...")
        
        db = Database()
        
        # Verificar existência da tabela briefings
        result = db.fetch_one(
            "SELECT name FROM sqlite_master WHERE type='table' AND name='briefings'"
        )
        
        if not result:
            print("❌ Tabela 'briefings' não encontrada!")
        else:
            print("✅ Tabela 'briefings' encontrada.")
            
            # Verificar colunas da tabela briefings
            result = db.fetch_all("PRAGMA table_info(briefings)")
            columns = [row[1] for row in result]
            
            required_columns = ['id', 'event_id', 'created_at', 'updated_at']
            missing_columns = [col for col in required_columns if col not in columns]
            
            if missing_columns:
                print(f"❌ Colunas ausentes na tabela 'briefings': {', '.join(missing_columns)}")
            else:
                print("✅ Estrutura da tabela 'briefings' está correta.")
        
        # Verificar existência da tabela briefing_items
        result = db.fetch_one(
            "SELECT name FROM sqlite_master WHERE type='table' AND name='briefing_items'"
        )
        
        if not result:
            print("❌ Tabela 'briefing_items' não encontrada!")
        else:
            print("✅ Tabela 'briefing_items' encontrada.")
            
            # Verificar colunas da tabela briefing_items
            result = db.fetch_all("PRAGMA table_info(briefing_items)")
            columns = [row[1] for row in result]
            
            required_columns = ['id', 'briefing_id', 'type', 'content', 'created_at', 'updated_at']
            missing_columns = [col for col in required_columns if col not in columns]
            
            if missing_columns:
                print(f"❌ Colunas ausentes na tabela 'briefing_items': {', '.join(missing_columns)}")
            else:
                print("✅ Estrutura da tabela 'briefing_items' está correta.")
        
        # Verificar existência do índice
        result = db.fetch_one(
            "SELECT name FROM sqlite_master WHERE type='index' AND name='idx_briefing_items'"
        )
        
        if not result:
            print("❌ Índice 'idx_briefing_items' não encontrado!")
        else:
            print("✅ Índice 'idx_briefing_items' encontrado.")
    
    except Exception as e:
        print(f"❌ Erro ao verificar estrutura do banco de dados: {str(e)}")
    finally:
        if 'db' in locals():
            db.close()


def check_briefing_repository():
    """Verifica o repositório de briefing"""
    try:
        print("\n📚 Verificando repositório de briefing...")
        
        # Instanciar o repositório
        briefing_repo = BriefingRepository()
        
        # Verificar métodos necessários
        required_methods = [
            'create_or_update_briefing',
            'get_briefing_by_event',
            'get_briefing_items_by_type'
        ]
        
        for method in required_methods:
            if hasattr(briefing_repo, method) and callable(getattr(briefing_repo, method)):
                print(f"✅ Método '{method}' implementado.")
            else:
                print(f"❌ Método '{method}' não implementado!")
    
    except Exception as e:
        print(f"❌ Erro ao verificar repositório de briefing: {str(e)}")


def check_event_integration():
    """Verifica integração com eventos"""
    try:
        print("\n🔄 Verificando integração com eventos...")
        
        # Instanciar repositórios
        briefing_repo = BriefingRepository()
        event_repo = EventRepository()
        
        # Verificar se há eventos disponíveis
        events = event_repo.get_all()
        
        if not events or len(events) == 0:
            print("⚠️ Nenhum evento disponível para teste de integração.")
            return
            
        # Pegar o primeiro evento para teste
        test_event = events[0]
        event_id = test_event['id']
        
        print(f"🧪 Testando com evento: {test_event['name']} (ID: {event_id})")
        
        # Verificar se existe um briefing para este evento
        briefing = briefing_repo.get_briefing_by_event(event_id)
        
        if briefing:
            print(f"✅ Briefing encontrado para o evento.")
            
            # Verificar estrutura do briefing
            if isinstance(briefing, dict):
                print("✅ Briefing retornado como dicionário.")
                
                for key in ['id', 'event_id']:
                    if key in briefing:
                        print(f"✅ Campo '{key}' presente no briefing.")
                    else:
                        print(f"❌ Campo '{key}' ausente no briefing!")
            else:
                print(f"❌ Briefing retornado com tipo inválido: {type(briefing)}")
        else:
            print("⚠️ Nenhum briefing encontrado para o evento (isto pode ser normal).")
    
    except Exception as e:
        print(f"❌ Erro ao verificar integração com eventos: {str(e)}")


if __name__ == "__main__":
    run_briefing_diagnostics()
```

### 3.3.4 Script de Diagnóstico para Timeline

```python name=diagnostico_melhorado_timeline.py
import os
import sys
import sqlite3
from datetime import datetime

# Adicionar diretório pai ao path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from database.Database import Database
from database.TimelineRepository import TimelineRepository
from database.EventRepository import EventRepository
from database.BriefingRepository import BriefingRepository


def run_timeline_diagnostics():
    """Executa diagnósticos na implementação da aba Timeline"""
    
    print("\n🔍 Executando diagnóstico da Aba TIMELINE...\n")
    
    # Verificar estrutura do banco de dados
    check_database_structure()
    
    # Verificar repositório de timeline
    check_timeline_repository()
    
    # Verificar integração com briefing
    check_briefing_integration()
    
    print("\n✅ Diagnóstico da Aba TIMELINE concluído!\n")


def check_database_structure():
    """Verifica a estrutura do banco de dados para timeline"""
    try:
        print("📊 Verificando estrutura do banco de dados...")
        
        db = Database()
        
        # Verificar existência da tabela timeline_events
        result = db.fetch_one(
            "SELECT name FROM sqlite_master WHERE type='table' AND name='timeline_events'"
        )
        
        if not result:
            print("❌ Tabela 'timeline_events' não encontrada!")
        else:
            print("✅ Tabela 'timeline_events' encontrada.")
            
            # Verificar colunas da tabela timeline_events
            result = db.fetch_all("PRAGMA table_info(timeline_events)")
            columns = [row[1] for row in result]
            
            required_columns = [
                'id', 'event_id', 'title', 'start_time', 'end_time', 'type', 
                'status', 'responsible_id', 'notes', 'created_at', 'updated_at'
            ]
            missing_columns = [col for col in required_columns if col not in columns]
            
            if missing_columns:
                print(f"❌ Colunas ausentes na tabela 'timeline_events': {', '.join(missing_columns)}")
            else:
                print("✅ Estrutura da tabela 'timeline_events' está correta.")
        
        # Verificar existência do índice
        result = db.fetch_one(
            "SELECT name FROM sqlite_master WHERE type='index' AND name='idx_timeline'"
        )
        
        if not result:
            print("❌ Índice 'idx_timeline' não encontrado!")
        else:
            print("✅ Índice 'idx_timeline' encontrado.")
    
    except Exception as e:
        print(f"❌ Erro ao verificar estrutura do banco de dados: {str(e)}")
    finally:
        if 'db' in locals():
            db.close()


def check_timeline_repository():
    """Verifica o repositório de timeline"""
    try:
        print("\n📚 Verificando repositório de timeline...")
        
        # Instanciar o repositório
        timeline_repo = TimelineRepository()
        
        # Verificar métodos necessários
        required_methods = [
            'generate_timeline_from_briefing',
            'get_timeline_by_event',
            'update_timeline_item',
            'check_conflicts'
        ]
        
        for method in required_methods:
            if hasattr(timeline_repo, method) and callable(getattr(timeline_repo, method)):
                print(f"✅ Método '{method}' implementado.")
            else:
                print(f"❌ Método '{method}' não implementado!")
    
    except Exception as e:
        print(f"❌ Erro ao verificar repositório de timeline: {str(e)}")


def check_briefing_integration():
    """Verifica integração com briefing"""
    try:
        print("\n🔄 Verificando integração com briefing...")
        
        # Instanciar repositórios
        timeline_repo = TimelineRepository()
        briefing_repo = BriefingRepository()
        event_repo = EventRepository()
        
        # Verificar se há eventos disponíveis
        events = event_repo.get_all()
        
        if not events or len(events) == 0:
            print("⚠️ Nenhum evento disponível para teste de integração.")
            return
            
        # Pegar o primeiro evento para teste
        test_event = events[0]
        event_id = test_event['id']
        
        print(f"🧪 Testando com evento: {test_event['name']} (ID: {event_id})")
        
        # Verificar se existe um briefing para este evento
        briefing = briefing_repo.get_briefing_by_event(event_id)
        
        if not briefing:
            print("⚠️ Nenhum briefing encontrado para o evento (necessário para teste de integração).")
            return
            
        print("✅ Briefing encontrado para o evento.")
        
        # Tentar gerar timeline a partir do briefing
        result = timeline_repo.generate_timeline_from_briefing(event_id)
        
        if result:
            print("✅ Timeline gerada com sucesso a partir do briefing.")
            
            # Verificar se a timeline foi gerada
            timeline_events = timeline_repo.get_timeline_by_event(event_id)
            
            if timeline_events and len(timeline_events) > 0:
                print(f"✅ {len(timeline_events)} eventos gerados na timeline.")
                
                # Verificar tipos de eventos gerados
                event_types = set(event["type"] for event in timeline_events if "type" in event)
                print(f"✅ Tipos de evento gerados: {', '.join(event_types)}")
            else:
                print("❌ Nenhum evento encontrado na timeline gerada!")
        else:
            print("❌ Falha ao gerar timeline a partir do briefing!")
    
    except Exception as e:
        print(f"❌ Erro ao verificar integração com briefing: {str(e)}")


if __name__ == "__main__":
    run_timeline_diagnostics()
```

## 4. Atualização do Arquivo de Inicialização Principal

Para garantir que as novas tabelas sejam criadas corretamente ao iniciar a aplicação, precisamos atualizar o script de inicialização:

```python name=main.py
import os
import sys
from PySide6.QtWidgets import QApplication

from database.schema.create_briefing_tables import create_briefing_tables
from database.schema.create_timeline_tables import create_timeline_tables
from gui.main_window import MainWindow
from utils.logger import get_logger

logger = get_logger()

def init_database():
    """Inicializa o banco de dados com todas as tabelas necessárias"""
    
    try:
        # Criar tabelas existentes (presumidamente já implementado)
        from database.init_db import init_database as init_existing_db
        init_existing_db()
        
        # Criar tabelas adicionais para briefing e timeline
        create_briefing_tables()
        create_timeline_tables()
        
        return True
        
    except Exception as e:
        logger.error(f"Erro ao inicializar banco de dados: {e}")
        return False


if __name__ == "__main__":
    # Inicializar banco de dados
    init_database()
    
    # Iniciar aplicação Qt
    app = QApplication(sys.argv)
    
    # Carregar estilo global (presumidamente já implementado)
    from utils.styles import apply_global_style
    apply_global_style(app)
    
    # Criar e exibir a janela principal
    window = MainWindow()
    window.show()
    
    # Executar o loop de eventos
    sys.exit(app.exec())
```

## 5. Documentação do Sistema

### 5.1 Documentação da Aba Briefing

```markdown name=docs/briefing.md
# Documentação da Aba Briefing

## Visão Geral

A aba Briefing permite a centralização estratégica completa de todos os aspectos relacionados a eventos audiovisuais. Ela serve como fonte principal de informações para as outras abas do sistema, incluindo Timeline, Edições, Entregas e Equipe.

## Principais Recursos

### 1. Informações Gerais e Estilo

- **Informações Gerais**: Campo para descrição abrangente do evento, público-alvo, objetivos, etc.
- **Estilo e Referências**: Local para definir a identidade visual e referências para edições.

### 2. Patrocinadores

Gerenciamento dinâmico de ações de patrocinadores, incluindo:
- Nome da ação
- Horário da captação (fixo ou livre)
- Responsável pela captação
- Opção de entrega em tempo real
- Editor responsável (para entregas em tempo real)
- Orientações específicas

### 3. Programação de Palcos

Tabela para gerenciar programação de atrações em diferentes palcos:
- Nome do palco
- Nome do artista/atração
- Horário de início e fim
- Observações específicas

### 4. Entregas

#### Entregas em Tempo Real
- Título da entrega
- Horário previsto
- Editor responsável
- Plataforma de destino
- Orientações específicas

#### Entregas Pós-Evento
- Deadline geral para todas as entregas
- Pacotes de entrega (Aftermovie, Highlights, Teaser, etc.)
- Observações gerais para entregas pós-evento

## Fluxo de Trabalho

1. Selecione um evento no seletor no topo da tela
2. Preencha as informações das diferentes seções do briefing
3. Salve o briefing usando o botão "Salvar Briefing"
4. Gere uma timeline baseada no briefing usando "Gerar Timeline"

## Integração com Outras Abas

- **Timeline**: Gerada automaticamente a partir dos dados do briefing
- **Edições**: Recebe automaticamente as entregas e editores definidos no briefing
- **Equipe**: Fornece os responsáveis por cada tarefa definida no briefing
- **Entregas**: Utiliza as definições de entregas do briefing para organizar o fluxo de trabalho

## Representação Técnica

O briefing é armazenado no banco de dados em uma estrutura flexível:
- Tabela `briefings`: Associação com evento e metadados
- Tabela `briefing_items`: Itens de diferentes tipos associados ao briefing

## Boas Práticas

- Preencha o briefing o mais detalhadamente possível antes de iniciar o evento
- Atualize o briefing sempre que houver mudanças significativas
- Gere a timeline novamente após alterações importantes no briefing
- Verifique conflitos na aba Timeline após gerar/atualizar a timeline
```

### 5.2 Documentação da Aba Timeline

```markdown name=docs/timeline.md
# Documentação da Aba Timeline

## Visão Geral

A aba Timeline oferece uma visualização gráfica das atividades planejadas para um evento, baseada nos dados definidos no Briefing. Ela permite monitoramento em tempo real, gerenciamento de conflitos e atualizações de status das atividades.

## Principais Recursos

### 1. Visualização Cronológica

- **Linha do Tempo Visual**: Representação gráfica das atividades por horário
- **Agrupamento por Tipo**: Divisão visual em categorias (captação, edição, entrega, etc.)
- **Cores por Status**: Diferenciação visual de acordo com o status da atividade

### 2. Gerenciamento de Atividades

- **Drag & Drop**: Reposicionamento de atividades na linha do tempo
- **Edição de Detalhes**: Modificação de título, horário, responsável, etc.
- **Atualização de Status**: Alteração rápida para Pendente, Em Andamento, Concluído, etc.

### 3. Ferramentas de Controle

- **Zoom**: Ajuste da escala de tempo para melhor visualização
- **Filtros**: Filtragem por tipo de atividade e responsável
- **Detecção de Conflitos**: Identificação automática de problemas como sobreposição de horários

## Fluxo de Trabalho

1. Selecione um evento no seletor no topo da tela
2. Visualize a timeline gerada a partir do briefing
3. Ajuste posições ou detalhes dos itens conforme necessário
4. Atualize o status das atividades conforme o evento progride
5. Verifique conflitos regularmente para evitar problemas logísticos

## Tipos de Atividades

- **Captação**: Gravações e registros durante o evento
- **Edição**: Processos de edição de conteúdo
- **Entrega**: Momentos de publicação ou entrega de conteúdo
- **Preparação**: Atividades preparatórias ou de organização
- **Outro**: Atividades diversas que não se encaixam nas categorias anteriores

## Status de Atividades

- **Pendente**: Ainda não iniciada
- **Em Andamento**: Iniciada mas não concluída
- **Concluído**: Finalizada com sucesso
- **Atrasado**: Não iniciada ou não concluída após o horário previsto
- **Cancelado**: Não será mais realizada

## Detecção de Conflitos

A timeline detecta automaticamente os seguintes tipos de conflitos:

1. **Sobreposição de Responsáveis**: Quando a mesma pessoa está designada para duas atividades simultâneas
2. **Entrega sem Edição**: Quando há uma entrega programada sem um período de edição anterior correspondente

## Integração com Outras Abas

- **Briefing**: Recebe os dados para geração inicial da timeline
- **Edições**: Fornece prazos e cronograma para o processo de edição
- **Entregas**: Define momentos de entrega e responsáveis
- **Equipe**: Utiliza e informa os responsáveis por cada atividade

## Representação Técnica

A timeline é armazenada no banco de dados na tabela `timeline_events`, que registra cada atividade com detalhes como:
- Título e descrição
- Horários de início e fim
- Tipo de atividade
- Status atual
- Responsável designado
```

## 6. Integração Final

Para finalizar a implementação das abas Briefing e Timeline, gere os arquivos necessários para integração da funcionalidade de "Gerar Timeline" entre as duas abas:

```python name=main.py
import os
import sys
from PySide6.QtWidgets import QApplication

from gui.main_window import MainWindow
from database.init_db import init_database
from utils.logger import get_logger

logger = get_logger()

if __name__ == "__main__":
    # Inicializar banco de dados
    init_database()
    logger.info("Banco de dados inicializado")
    
    # Iniciar aplicação
    app = QApplication(sys.argv)
    
    # Aplicar estilos (presumindo que isso já existe)
    from utils.styles import set_app_style
    set_app_style(app)
    
    # Criar e exibir a janela principal
    window = MainWindow()
    window.show()
    
    # Executar o loop de eventos
    sys.exit(app.exec())
```

Desta forma, as abas Briefing e Timeline estão completamente implementadas, testadas e integradas ao sistema GoNetwork AI, fornecendo uma solução eficiente para gerenciamento de eventos audiovisuais.